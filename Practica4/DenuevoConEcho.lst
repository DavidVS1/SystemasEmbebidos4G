CCS PCH C Compiler, Version 5.012, 41559               26-abr.-17 19:37

               Filename:   C:\Users\luis\Documents\4Semestre\Embebidos\SystemasEmbebidos4G\Practica4\DenuevoConEcho.lst

               ROM used:   4086 bytes (6%)
                           Largest free fragment is 61446
               RAM used:   45 (1%) at main() level
                           93 (2%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   0C52
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  F9D.5
0004A:  GOTO   0054
0004E:  BTFSC  F9E.5
00050:  GOTO   0096
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... #include <18F4620.h> 
.................... ///////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
*
0013E:  DATA 50,72
00140:  DATA 61,63
00142:  DATA 74,69
00144:  DATA 63,61
00146:  DATA 20,4E
00148:  DATA 6F,2E
0014A:  DATA 20,34
0014C:  DATA 0D,00
0014E:  DATA 43,61
00150:  DATA 6C,63
00152:  DATA 75,6C
00154:  DATA 61,64
00156:  DATA 6F,72
00158:  DATA 61,20
0015A:  DATA 41,72
0015C:  DATA 69,74
0015E:  DATA 6D,65
00160:  DATA 74,69
00162:  DATA 63,61
00164:  DATA 20,0D
00166:  DATA 0D,00
00168:  DATA 49,6E
0016A:  DATA 67,72
0016C:  DATA 65,73
0016E:  DATA 61,20
00170:  DATA 65,6C
00172:  DATA 20,70
00174:  DATA 72,69
00176:  DATA 6D,65
00178:  DATA 72,20
0017A:  DATA 6F,70
0017C:  DATA 65,72
0017E:  DATA 61,6E
00180:  DATA 64,6F
00182:  DATA 20,0D
00184:  DATA 00,00
00186:  DATA 45,72
00188:  DATA 72,6F
0018A:  DATA 72,20
0018C:  DATA 0D,00
0018E:  DATA 53,65
00190:  DATA 20,68
00192:  DATA 61,20
00194:  DATA 74,65
00196:  DATA 72,6D
00198:  DATA 69,6E
0019A:  DATA 61,64
0019C:  DATA 6F,20
0019E:  DATA 65,6C
001A0:  DATA 20,74
001A2:  DATA 69,65
001A4:  DATA 6D,70
001A6:  DATA 6F,00
001A8:  DATA 49,6E
001AA:  DATA 67,72
001AC:  DATA 65,73
001AE:  DATA 61,20
001B0:  DATA 65,6C
001B2:  DATA 20,73
001B4:  DATA 65,67
001B6:  DATA 75,6E
001B8:  DATA 64,6F
001BA:  DATA 20,6F
001BC:  DATA 70,65
001BE:  DATA 72,61
001C0:  DATA 6E,64
001C2:  DATA 6F,20
001C4:  DATA 0D,00
001C6:  DATA 45,72
001C8:  DATA 72,6F
001CA:  DATA 72,20
001CC:  DATA 0D,00
001CE:  DATA 53,65
001D0:  DATA 20,68
001D2:  DATA 61,20
001D4:  DATA 74,65
001D6:  DATA 72,6D
001D8:  DATA 69,6E
001DA:  DATA 61,64
001DC:  DATA 6F,20
001DE:  DATA 65,6C
001E0:  DATA 20,74
001E2:  DATA 69,65
001E4:  DATA 6D,70
001E6:  DATA 6F,00
001E8:  DATA 53,65
001EA:  DATA 6C,65
001EC:  DATA 63,63
001EE:  DATA 69,6F
001F0:  DATA 6E,65
001F2:  DATA 20,75
001F4:  DATA 6E,61
001F6:  DATA 20,6F
001F8:  DATA 70,65
001FA:  DATA 72,61
001FC:  DATA 63,69
001FE:  DATA 6F,6E
00200:  DATA 3A,20
00202:  DATA 0D,20
00204:  DATA 31,29
00206:  DATA 53,75
00208:  DATA 6D,61
0020A:  DATA 20,20
0020C:  DATA 32,29
0020E:  DATA 52,65
00210:  DATA 73,74
00212:  DATA 61,20
00214:  DATA 20,33
00216:  DATA 29,4D
00218:  DATA 75,6C
0021A:  DATA 74,69
0021C:  DATA 70,6C
0021E:  DATA 69,63
00220:  DATA 61,63
00222:  DATA 69,6F
00224:  DATA 6E,20
00226:  DATA 20,34
00228:  DATA 29,44
0022A:  DATA 69,76
0022C:  DATA 69,73
0022E:  DATA 69,6F
00230:  DATA 6E,20
00232:  DATA 0D,00
00234:  DATA 45,72
00236:  DATA 72,6F
00238:  DATA 72,20
0023A:  DATA 0D,00
0023C:  DATA 53,65
0023E:  DATA 20,68
00240:  DATA 61,20
00242:  DATA 74,65
00244:  DATA 72,6D
00246:  DATA 69,6E
00248:  DATA 61,64
0024A:  DATA 6F,20
0024C:  DATA 65,6C
0024E:  DATA 20,74
00250:  DATA 69,65
00252:  DATA 6D,70
00254:  DATA 6F,00
00256:  DATA 45,6C
00258:  DATA 20,72
0025A:  DATA 65,73
0025C:  DATA 75,6C
0025E:  DATA 74,61
00260:  DATA 64,6F
00262:  DATA 20,64
00264:  DATA 65,20
00266:  DATA 6C,61
00268:  DATA 20,6F
0026A:  DATA 70,65
0026C:  DATA 72,61
0026E:  DATA 63,69
00270:  DATA 6F,6E
00272:  DATA 20,65
00274:  DATA 73,3A
00276:  DATA 20,25
00278:  DATA 34,2E
0027A:  DATA 34,66
0027C:  DATA 0D,0D
0027E:  DATA 00,00
*
002A0:  TBLRD*+
002A2:  MOVF   FF5,F
002A4:  BZ    02C0
002A6:  MOVFF  FF6,38
002AA:  MOVFF  FF7,39
002AE:  MOVF   FF5,W
002B0:  BTFSS  F9E.4
002B2:  BRA    02B0
002B4:  MOVWF  FAD
002B6:  MOVFF  38,FF6
002BA:  MOVFF  39,FF7
002BE:  BRA    02A0
002C0:  RETURN 0
002C2:  MOVF   47,W
002C4:  BTFSC  FD8.2
002C6:  BRA    03AA
002C8:  MOVWF  00
002CA:  MOVF   4B,W
002CC:  BTFSC  FD8.2
002CE:  BRA    03AA
002D0:  ADDWF  00,F
002D2:  BNC   02DC
002D4:  MOVLW  81
002D6:  ADDWF  00,F
002D8:  BC    03AA
002DA:  BRA    02E4
002DC:  MOVLW  7F
002DE:  SUBWF  00,F
002E0:  BNC   03AA
002E2:  BZ    03AA
002E4:  MOVFF  48,4F
002E8:  MOVF   4C,W
002EA:  XORWF  4F,F
002EC:  BSF    48.7
002EE:  BSF    4C.7
002F0:  MOVF   4A,W
002F2:  MULWF  4E
002F4:  MOVFF  FF4,51
002F8:  MOVF   49,W
002FA:  MULWF  4D
002FC:  MOVFF  FF4,03
00300:  MOVFF  FF3,50
00304:  MULWF  4E
00306:  MOVF   FF3,W
00308:  ADDWF  51,F
0030A:  MOVF   FF4,W
0030C:  ADDWFC 50,F
0030E:  MOVLW  00
00310:  ADDWFC 03,F
00312:  MOVF   4A,W
00314:  MULWF  4D
00316:  MOVF   FF3,W
00318:  ADDWF  51,F
0031A:  MOVF   FF4,W
0031C:  ADDWFC 50,F
0031E:  MOVLW  00
00320:  CLRF   02
00322:  ADDWFC 03,F
00324:  ADDWFC 02,F
00326:  MOVF   48,W
00328:  MULWF  4E
0032A:  MOVF   FF3,W
0032C:  ADDWF  50,F
0032E:  MOVF   FF4,W
00330:  ADDWFC 03,F
00332:  MOVLW  00
00334:  ADDWFC 02,F
00336:  MOVF   48,W
00338:  MULWF  4D
0033A:  MOVF   FF3,W
0033C:  ADDWF  03,F
0033E:  MOVF   FF4,W
00340:  ADDWFC 02,F
00342:  MOVLW  00
00344:  CLRF   01
00346:  ADDWFC 01,F
00348:  MOVF   4A,W
0034A:  MULWF  4C
0034C:  MOVF   FF3,W
0034E:  ADDWF  50,F
00350:  MOVF   FF4,W
00352:  ADDWFC 03,F
00354:  MOVLW  00
00356:  ADDWFC 02,F
00358:  ADDWFC 01,F
0035A:  MOVF   49,W
0035C:  MULWF  4C
0035E:  MOVF   FF3,W
00360:  ADDWF  03,F
00362:  MOVF   FF4,W
00364:  ADDWFC 02,F
00366:  MOVLW  00
00368:  ADDWFC 01,F
0036A:  MOVF   48,W
0036C:  MULWF  4C
0036E:  MOVF   FF3,W
00370:  ADDWF  02,F
00372:  MOVF   FF4,W
00374:  ADDWFC 01,F
00376:  INCF   00,F
00378:  BTFSC  01.7
0037A:  BRA    0386
0037C:  RLCF   50,F
0037E:  RLCF   03,F
00380:  RLCF   02,F
00382:  RLCF   01,F
00384:  DECF   00,F
00386:  MOVLW  00
00388:  BTFSS  50.7
0038A:  BRA    03A0
0038C:  INCF   03,F
0038E:  ADDWFC 02,F
00390:  ADDWFC 01,F
00392:  MOVF   01,W
00394:  BNZ   03A0
00396:  MOVF   02,W
00398:  BNZ   03A0
0039A:  MOVF   03,W
0039C:  BNZ   03A0
0039E:  INCF   00,F
003A0:  BTFSC  4F.7
003A2:  BSF    01.7
003A4:  BTFSS  4F.7
003A6:  BCF    01.7
003A8:  BRA    03B2
003AA:  CLRF   00
003AC:  CLRF   01
003AE:  CLRF   02
003B0:  CLRF   03
003B2:  RETURN 0
003B4:  MOVLW  8E
003B6:  MOVWF  00
003B8:  MOVFF  4C,01
003BC:  MOVFF  4B,02
003C0:  CLRF   03
003C2:  MOVF   01,F
003C4:  BNZ   03D8
003C6:  MOVFF  02,01
003CA:  CLRF   02
003CC:  MOVLW  08
003CE:  SUBWF  00,F
003D0:  MOVF   01,F
003D2:  BNZ   03D8
003D4:  CLRF   00
003D6:  BRA    03E8
003D8:  BCF    FD8.0
003DA:  BTFSC  01.7
003DC:  BRA    03E6
003DE:  RLCF   02,F
003E0:  RLCF   01,F
003E2:  DECF   00,F
003E4:  BRA    03D8
003E6:  BCF    01.7
003E8:  RETURN 0
003EA:  MOVF   4B,W
003EC:  BTFSC  FD8.2
003EE:  BRA    053A
003F0:  MOVWF  57
003F2:  MOVF   4F,W
003F4:  BTFSC  FD8.2
003F6:  BRA    053A
003F8:  SUBWF  57,F
003FA:  BNC   0406
003FC:  MOVLW  7F
003FE:  ADDWF  57,F
00400:  BTFSC  FD8.0
00402:  BRA    053A
00404:  BRA    0412
00406:  MOVLW  81
00408:  SUBWF  57,F
0040A:  BTFSS  FD8.0
0040C:  BRA    053A
0040E:  BTFSC  FD8.2
00410:  BRA    053A
00412:  MOVFF  57,00
00416:  CLRF   01
00418:  CLRF   02
0041A:  CLRF   03
0041C:  CLRF   56
0041E:  MOVFF  4C,55
00422:  BSF    55.7
00424:  MOVFF  4D,54
00428:  MOVFF  4E,53
0042C:  MOVLW  19
0042E:  MOVWF  57
00430:  MOVF   52,W
00432:  SUBWF  53,F
00434:  BC    0450
00436:  MOVLW  01
00438:  SUBWF  54,F
0043A:  BC    0450
0043C:  SUBWF  55,F
0043E:  BC    0450
00440:  SUBWF  56,F
00442:  BC    0450
00444:  INCF   56,F
00446:  INCF   55,F
00448:  INCF   54,F
0044A:  MOVF   52,W
0044C:  ADDWF  53,F
0044E:  BRA    04A0
00450:  MOVF   51,W
00452:  SUBWF  54,F
00454:  BC    047A
00456:  MOVLW  01
00458:  SUBWF  55,F
0045A:  BC    047A
0045C:  SUBWF  56,F
0045E:  BC    047A
00460:  INCF   56,F
00462:  INCF   55,F
00464:  MOVF   51,W
00466:  ADDWF  54,F
00468:  MOVF   52,W
0046A:  ADDWF  53,F
0046C:  BNC   04A0
0046E:  INCF   54,F
00470:  BNZ   04A0
00472:  INCF   55,F
00474:  BNZ   04A0
00476:  INCF   56,F
00478:  BRA    04A0
0047A:  MOVF   50,W
0047C:  IORLW  80
0047E:  SUBWF  55,F
00480:  BC    049E
00482:  MOVLW  01
00484:  SUBWF  56,F
00486:  BC    049E
00488:  INCF   56,F
0048A:  MOVF   50,W
0048C:  IORLW  80
0048E:  ADDWF  55,F
00490:  MOVF   51,W
00492:  ADDWF  54,F
00494:  BNC   0468
00496:  INCF   55,F
00498:  BNZ   0468
0049A:  INCF   56,F
0049C:  BRA    0468
0049E:  BSF    03.0
004A0:  DECFSZ 57,F
004A2:  BRA    04A6
004A4:  BRA    04BC
004A6:  BCF    FD8.0
004A8:  RLCF   53,F
004AA:  RLCF   54,F
004AC:  RLCF   55,F
004AE:  RLCF   56,F
004B0:  BCF    FD8.0
004B2:  RLCF   03,F
004B4:  RLCF   02,F
004B6:  RLCF   01,F
004B8:  RLCF   58,F
004BA:  BRA    0430
004BC:  BTFSS  58.0
004BE:  BRA    04CC
004C0:  BCF    FD8.0
004C2:  RRCF   01,F
004C4:  RRCF   02,F
004C6:  RRCF   03,F
004C8:  RRCF   58,F
004CA:  BRA    04D0
004CC:  DECF   00,F
004CE:  BZ    053A
004D0:  BTFSC  58.7
004D2:  BRA    0510
004D4:  BCF    FD8.0
004D6:  RLCF   53,F
004D8:  RLCF   54,F
004DA:  RLCF   55,F
004DC:  RLCF   56,F
004DE:  MOVF   52,W
004E0:  SUBWF  53,F
004E2:  BC    04F2
004E4:  MOVLW  01
004E6:  SUBWF  54,F
004E8:  BC    04F2
004EA:  SUBWF  55,F
004EC:  BC    04F2
004EE:  SUBWF  56,F
004F0:  BNC   0526
004F2:  MOVF   51,W
004F4:  SUBWF  54,F
004F6:  BC    0502
004F8:  MOVLW  01
004FA:  SUBWF  55,F
004FC:  BC    0502
004FE:  SUBWF  56,F
00500:  BNC   0526
00502:  MOVF   50,W
00504:  IORLW  80
00506:  SUBWF  55,F
00508:  BC    0510
0050A:  MOVLW  01
0050C:  SUBWF  56,F
0050E:  BNC   0526
00510:  INCF   03,F
00512:  BNZ   0526
00514:  INCF   02,F
00516:  BNZ   0526
00518:  INCF   01,F
0051A:  BNZ   0526
0051C:  INCF   00,F
0051E:  BZ    053A
00520:  RRCF   01,F
00522:  RRCF   02,F
00524:  RRCF   03,F
00526:  MOVFF  4C,57
0052A:  MOVF   50,W
0052C:  XORWF  57,F
0052E:  BTFSS  57.7
00530:  BRA    0536
00532:  BSF    01.7
00534:  BRA    0542
00536:  BCF    01.7
00538:  BRA    0542
0053A:  CLRF   00
0053C:  CLRF   01
0053E:  CLRF   02
00540:  CLRF   03
00542:  RETURN 0
00544:  MOVLW  80
00546:  BTFSC  FD8.1
00548:  XORWF  50,F
0054A:  CLRF   55
0054C:  CLRF   56
0054E:  MOVFF  4C,54
00552:  MOVF   50,W
00554:  XORWF  54,F
00556:  MOVF   4B,W
00558:  BTFSC  FD8.2
0055A:  BRA    0714
0055C:  MOVWF  53
0055E:  MOVWF  00
00560:  MOVF   4F,W
00562:  BTFSC  FD8.2
00564:  BRA    0726
00566:  SUBWF  53,F
00568:  BTFSC  FD8.2
0056A:  BRA    066E
0056C:  BNC   05E8
0056E:  MOVFF  50,59
00572:  BSF    59.7
00574:  MOVFF  51,58
00578:  MOVFF  52,57
0057C:  CLRF   56
0057E:  BCF    FD8.0
00580:  RRCF   59,F
00582:  RRCF   58,F
00584:  RRCF   57,F
00586:  RRCF   56,F
00588:  DECFSZ 53,F
0058A:  BRA    057C
0058C:  BTFSS  54.7
0058E:  BRA    0596
00590:  BSF    55.0
00592:  BRA    074E
00594:  BCF    55.0
00596:  BCF    53.0
00598:  BSF    55.4
0059A:  CLRF   FEA
0059C:  MOVLW  4E
0059E:  MOVWF  FE9
005A0:  BRA    0774
005A2:  BCF    55.4
005A4:  BTFSC  54.7
005A6:  BRA    05BC
005A8:  BTFSS  53.0
005AA:  BRA    05D2
005AC:  RRCF   59,F
005AE:  RRCF   58,F
005B0:  RRCF   57,F
005B2:  RRCF   56,F
005B4:  INCF   00,F
005B6:  BTFSC  FD8.2
005B8:  BRA    0744
005BA:  BRA    05D2
005BC:  BTFSC  59.7
005BE:  BRA    05D8
005C0:  BCF    FD8.0
005C2:  RLCF   56,F
005C4:  RLCF   57,F
005C6:  RLCF   58,F
005C8:  RLCF   59,F
005CA:  DECF   00,F
005CC:  BTFSC  FD8.2
005CE:  BRA    0744
005D0:  BRA    05BC
005D2:  BSF    55.6
005D4:  BRA    06AC
005D6:  BCF    55.6
005D8:  MOVFF  4C,54
005DC:  BTFSS  4C.7
005DE:  BRA    05E4
005E0:  BSF    59.7
005E2:  BRA    0736
005E4:  BCF    59.7
005E6:  BRA    0736
005E8:  MOVFF  4F,53
005EC:  MOVFF  4F,00
005F0:  MOVF   4B,W
005F2:  SUBWF  53,F
005F4:  MOVFF  4C,59
005F8:  BSF    59.7
005FA:  MOVFF  4D,58
005FE:  MOVFF  4E,57
00602:  CLRF   56
00604:  BCF    FD8.0
00606:  RRCF   59,F
00608:  RRCF   58,F
0060A:  RRCF   57,F
0060C:  RRCF   56,F
0060E:  DECFSZ 53,F
00610:  BRA    0602
00612:  BTFSS  54.7
00614:  BRA    061C
00616:  BSF    55.1
00618:  BRA    074E
0061A:  BCF    55.1
0061C:  BCF    53.0
0061E:  BSF    55.5
00620:  CLRF   FEA
00622:  MOVLW  52
00624:  MOVWF  FE9
00626:  BRA    0774
00628:  BCF    55.5
0062A:  BTFSC  54.7
0062C:  BRA    0642
0062E:  BTFSS  53.0
00630:  BRA    0658
00632:  RRCF   59,F
00634:  RRCF   58,F
00636:  RRCF   57,F
00638:  RRCF   56,F
0063A:  INCF   00,F
0063C:  BTFSC  FD8.2
0063E:  BRA    0744
00640:  BRA    0658
00642:  BTFSC  59.7
00644:  BRA    065E
00646:  BCF    FD8.0
00648:  RLCF   56,F
0064A:  RLCF   57,F
0064C:  RLCF   58,F
0064E:  RLCF   59,F
00650:  DECF   00,F
00652:  BTFSC  FD8.2
00654:  BRA    0744
00656:  BRA    0642
00658:  BSF    55.7
0065A:  BRA    06AC
0065C:  BCF    55.7
0065E:  MOVFF  50,54
00662:  BTFSS  50.7
00664:  BRA    066A
00666:  BSF    59.7
00668:  BRA    0736
0066A:  BCF    59.7
0066C:  BRA    0736
0066E:  MOVFF  50,59
00672:  BSF    59.7
00674:  MOVFF  51,58
00678:  MOVFF  52,57
0067C:  BTFSS  54.7
0067E:  BRA    0688
00680:  BCF    59.7
00682:  BSF    55.2
00684:  BRA    074E
00686:  BCF    55.2
00688:  CLRF   56
0068A:  BCF    53.0
0068C:  CLRF   FEA
0068E:  MOVLW  4E
00690:  MOVWF  FE9
00692:  BRA    0774
00694:  BTFSC  54.7
00696:  BRA    06D0
00698:  MOVFF  4C,54
0069C:  BTFSS  53.0
0069E:  BRA    06AC
006A0:  RRCF   59,F
006A2:  RRCF   58,F
006A4:  RRCF   57,F
006A6:  RRCF   56,F
006A8:  INCF   00,F
006AA:  BZ    0744
006AC:  BTFSS  56.7
006AE:  BRA    06C6
006B0:  INCF   57,F
006B2:  BNZ   06C6
006B4:  INCF   58,F
006B6:  BNZ   06C6
006B8:  INCF   59,F
006BA:  BNZ   06C6
006BC:  RRCF   59,F
006BE:  RRCF   58,F
006C0:  RRCF   57,F
006C2:  INCF   00,F
006C4:  BZ    0744
006C6:  BTFSC  55.6
006C8:  BRA    05D6
006CA:  BTFSC  55.7
006CC:  BRA    065C
006CE:  BRA    0708
006D0:  MOVLW  80
006D2:  XORWF  59,F
006D4:  BTFSS  59.7
006D6:  BRA    06E0
006D8:  BRA    074E
006DA:  MOVFF  50,54
006DE:  BRA    06F4
006E0:  MOVFF  4C,54
006E4:  MOVF   59,F
006E6:  BNZ   06F4
006E8:  MOVF   58,F
006EA:  BNZ   06F4
006EC:  MOVF   57,F
006EE:  BNZ   06F4
006F0:  CLRF   00
006F2:  BRA    0736
006F4:  BTFSC  59.7
006F6:  BRA    0708
006F8:  BCF    FD8.0
006FA:  RLCF   56,F
006FC:  RLCF   57,F
006FE:  RLCF   58,F
00700:  RLCF   59,F
00702:  DECFSZ 00,F
00704:  BRA    06F4
00706:  BRA    0744
00708:  BTFSS  54.7
0070A:  BRA    0710
0070C:  BSF    59.7
0070E:  BRA    0736
00710:  BCF    59.7
00712:  BRA    0736
00714:  MOVFF  4F,00
00718:  MOVFF  50,59
0071C:  MOVFF  51,58
00720:  MOVFF  52,57
00724:  BRA    0736
00726:  MOVFF  4B,00
0072A:  MOVFF  4C,59
0072E:  MOVFF  4D,58
00732:  MOVFF  4E,57
00736:  MOVFF  59,01
0073A:  MOVFF  58,02
0073E:  MOVFF  57,03
00742:  BRA    07AC
00744:  CLRF   00
00746:  CLRF   01
00748:  CLRF   02
0074A:  CLRF   03
0074C:  BRA    07AC
0074E:  CLRF   56
00750:  COMF   57,F
00752:  COMF   58,F
00754:  COMF   59,F
00756:  COMF   56,F
00758:  INCF   56,F
0075A:  BNZ   0766
0075C:  INCF   57,F
0075E:  BNZ   0766
00760:  INCF   58,F
00762:  BNZ   0766
00764:  INCF   59,F
00766:  BTFSC  55.0
00768:  BRA    0594
0076A:  BTFSC  55.1
0076C:  BRA    061A
0076E:  BTFSC  55.2
00770:  BRA    0686
00772:  BRA    06DA
00774:  MOVF   FEF,W
00776:  ADDWF  57,F
00778:  BNC   0784
0077A:  INCF   58,F
0077C:  BNZ   0784
0077E:  INCF   59,F
00780:  BTFSC  FD8.2
00782:  BSF    53.0
00784:  MOVF   FED,F
00786:  MOVF   FEF,W
00788:  ADDWF  58,F
0078A:  BNC   0792
0078C:  INCF   59,F
0078E:  BTFSC  FD8.2
00790:  BSF    53.0
00792:  MOVF   FED,F
00794:  MOVF   FEF,W
00796:  BTFSC  FEF.7
00798:  BRA    079C
0079A:  XORLW  80
0079C:  ADDWF  59,F
0079E:  BTFSC  FD8.0
007A0:  BSF    53.0
007A2:  BTFSC  55.4
007A4:  BRA    05A2
007A6:  BTFSC  55.5
007A8:  BRA    0628
007AA:  BRA    0694
007AC:  RETURN 0
*
009E0:  MOVF   45,W
009E2:  SUBLW  B6
009E4:  MOVWF  45
009E6:  CLRF   03
009E8:  MOVFF  46,49
009EC:  BSF    46.7
009EE:  BCF    FD8.0
009F0:  RRCF   46,F
009F2:  RRCF   47,F
009F4:  RRCF   48,F
009F6:  RRCF   03,F
009F8:  RRCF   02,F
009FA:  RRCF   01,F
009FC:  RRCF   00,F
009FE:  DECFSZ 45,F
00A00:  BRA    09EE
00A02:  BTFSS  49.7
00A04:  BRA    0A1C
00A06:  COMF   00,F
00A08:  COMF   01,F
00A0A:  COMF   02,F
00A0C:  COMF   03,F
00A0E:  INCF   00,F
00A10:  BTFSC  FD8.2
00A12:  INCF   01,F
00A14:  BTFSC  FD8.2
00A16:  INCF   02,F
00A18:  BTFSC  FD8.2
00A1A:  INCF   03,F
00A1C:  GOTO   0AFE (RETURN)
00A20:  BTFSC  FD8.1
00A22:  BRA    0A2A
00A24:  CLRF   FEA
00A26:  MOVLW  4D
00A28:  MOVWF  FE9
00A2A:  CLRF   00
00A2C:  CLRF   01
00A2E:  CLRF   02
00A30:  CLRF   03
00A32:  CLRF   4D
00A34:  CLRF   4E
00A36:  CLRF   4F
00A38:  CLRF   50
00A3A:  MOVF   4C,W
00A3C:  IORWF  4B,W
00A3E:  IORWF  4A,W
00A40:  IORWF  49,W
00A42:  BZ    0A9C
00A44:  MOVLW  20
00A46:  MOVWF  51
00A48:  BCF    FD8.0
00A4A:  RLCF   45,F
00A4C:  RLCF   46,F
00A4E:  RLCF   47,F
00A50:  RLCF   48,F
00A52:  RLCF   4D,F
00A54:  RLCF   4E,F
00A56:  RLCF   4F,F
00A58:  RLCF   50,F
00A5A:  MOVF   4C,W
00A5C:  SUBWF  50,W
00A5E:  BNZ   0A70
00A60:  MOVF   4B,W
00A62:  SUBWF  4F,W
00A64:  BNZ   0A70
00A66:  MOVF   4A,W
00A68:  SUBWF  4E,W
00A6A:  BNZ   0A70
00A6C:  MOVF   49,W
00A6E:  SUBWF  4D,W
00A70:  BNC   0A90
00A72:  MOVF   49,W
00A74:  SUBWF  4D,F
00A76:  MOVF   4A,W
00A78:  BTFSS  FD8.0
00A7A:  INCFSZ 4A,W
00A7C:  SUBWF  4E,F
00A7E:  MOVF   4B,W
00A80:  BTFSS  FD8.0
00A82:  INCFSZ 4B,W
00A84:  SUBWF  4F,F
00A86:  MOVF   4C,W
00A88:  BTFSS  FD8.0
00A8A:  INCFSZ 4C,W
00A8C:  SUBWF  50,F
00A8E:  BSF    FD8.0
00A90:  RLCF   00,F
00A92:  RLCF   01,F
00A94:  RLCF   02,F
00A96:  RLCF   03,F
00A98:  DECFSZ 51,F
00A9A:  BRA    0A48
00A9C:  MOVFF  4D,FEF
00AA0:  MOVFF  4E,FEC
00AA4:  MOVFF  4F,FEC
00AA8:  MOVFF  50,FEC
00AAC:  RETURN 0
00AAE:  MOVF   FE9,W
00AB0:  MOVWF  3D
00AB2:  MOVF   3C,W
00AB4:  MOVWF  3F
00AB6:  BZ    0AEC
00AB8:  MOVFF  3B,4A
00ABC:  MOVFF  3A,49
00AC0:  MOVFF  39,48
00AC4:  MOVFF  38,47
00AC8:  CLRF   4E
00ACA:  CLRF   4D
00ACC:  MOVLW  20
00ACE:  MOVWF  4C
00AD0:  MOVLW  82
00AD2:  MOVWF  4B
00AD4:  CALL   02C2
00AD8:  MOVFF  03,3B
00ADC:  MOVFF  02,3A
00AE0:  MOVFF  01,39
00AE4:  MOVFF  00,38
00AE8:  DECFSZ 3F,F
00AEA:  BRA    0AB8
00AEC:  MOVFF  3B,48
00AF0:  MOVFF  3A,47
00AF4:  MOVFF  39,46
00AF8:  MOVFF  38,45
00AFC:  BRA    09E0
00AFE:  MOVFF  03,3B
00B02:  MOVFF  02,3A
00B06:  MOVFF  01,39
00B0A:  MOVFF  00,38
00B0E:  BTFSS  3B.7
00B10:  BRA    0B2C
00B12:  DECF   3D,F
00B14:  BSF    3D.5
00B16:  COMF   38,F
00B18:  COMF   39,F
00B1A:  COMF   3A,F
00B1C:  COMF   3B,F
00B1E:  INCF   38,F
00B20:  BTFSC  FD8.2
00B22:  INCF   39,F
00B24:  BTFSC  FD8.2
00B26:  INCF   3A,F
00B28:  BTFSC  FD8.2
00B2A:  INCF   3B,F
00B2C:  MOVLW  3B
00B2E:  MOVWF  44
00B30:  MOVLW  9A
00B32:  MOVWF  43
00B34:  MOVLW  CA
00B36:  MOVWF  42
00B38:  CLRF   41
00B3A:  MOVLW  0A
00B3C:  MOVWF  3F
00B3E:  MOVF   3C,W
00B40:  BTFSC  FD8.2
00B42:  INCF   3D,F
00B44:  BSF    FD8.1
00B46:  CLRF   FEA
00B48:  MOVLW  38
00B4A:  MOVWF  FE9
00B4C:  MOVFF  3B,48
00B50:  MOVFF  3A,47
00B54:  MOVFF  39,46
00B58:  MOVFF  38,45
00B5C:  MOVFF  44,4C
00B60:  MOVFF  43,4B
00B64:  MOVFF  42,4A
00B68:  MOVFF  41,49
00B6C:  RCALL  0A20
00B6E:  MOVF   01,W
00B70:  MOVF   00,F
00B72:  BNZ   0B92
00B74:  INCF   3C,W
00B76:  SUBWF  3F,W
00B78:  BZ    0B92
00B7A:  MOVF   3D,W
00B7C:  BZ    0B96
00B7E:  ANDLW  0F
00B80:  SUBWF  3F,W
00B82:  BZ    0B86
00B84:  BC    0BFC
00B86:  BTFSC  3D.7
00B88:  BRA    0BFC
00B8A:  BTFSC  3D.6
00B8C:  BRA    0B96
00B8E:  MOVLW  20
00B90:  BRA    0BF2
00B92:  MOVLW  20
00B94:  ANDWF  3D,F
00B96:  BTFSS  3D.5
00B98:  BRA    0BB4
00B9A:  BCF    3D.5
00B9C:  MOVF   3C,W
00B9E:  BTFSS  FD8.2
00BA0:  DECF   3D,F
00BA2:  MOVF   00,W
00BA4:  MOVWF  3D
00BA6:  MOVLW  2D
00BA8:  BTFSS  F9E.4
00BAA:  BRA    0BA8
00BAC:  MOVWF  FAD
00BAE:  MOVF   3D,W
00BB0:  MOVWF  00
00BB2:  CLRF   3D
00BB4:  MOVF   3C,W
00BB6:  SUBWF  3F,W
00BB8:  BNZ   0BD0
00BBA:  MOVF   00,W
00BBC:  MOVWF  3D
00BBE:  MOVLW  2E
00BC0:  BTFSS  F9E.4
00BC2:  BRA    0BC0
00BC4:  MOVWF  FAD
00BC6:  MOVF   3D,W
00BC8:  MOVWF  00
00BCA:  MOVLW  20
00BCC:  ANDWF  3D,F
00BCE:  MOVLW  00
00BD0:  MOVLW  30
00BD2:  BTFSS  3D.5
00BD4:  BRA    0BF2
00BD6:  BCF    3D.5
00BD8:  MOVF   3C,W
00BDA:  BTFSS  FD8.2
00BDC:  DECF   3D,F
00BDE:  MOVF   00,W
00BE0:  MOVWF  3D
00BE2:  MOVLW  2D
00BE4:  BTFSS  F9E.4
00BE6:  BRA    0BE4
00BE8:  MOVWF  FAD
00BEA:  MOVF   3D,W
00BEC:  MOVWF  00
00BEE:  CLRF   3D
00BF0:  MOVLW  30
00BF2:  ADDWF  00,F
00BF4:  MOVF   00,W
00BF6:  BTFSS  F9E.4
00BF8:  BRA    0BF6
00BFA:  MOVWF  FAD
00BFC:  BCF    FD8.1
00BFE:  MOVFF  44,48
00C02:  MOVFF  43,47
00C06:  MOVFF  42,46
00C0A:  MOVFF  41,45
00C0E:  CLRF   4C
00C10:  CLRF   4B
00C12:  CLRF   4A
00C14:  MOVLW  0A
00C16:  MOVWF  49
00C18:  RCALL  0A20
00C1A:  MOVFF  03,44
00C1E:  MOVFF  02,43
00C22:  MOVFF  01,42
00C26:  MOVFF  00,41
00C2A:  DECFSZ 3F,F
00C2C:  BRA    0B44
00C2E:  RETURN 0
00C30:  TBLRD*+
00C32:  MOVFF  FF6,39
00C36:  MOVFF  FF7,3A
00C3A:  MOVF   FF5,W
00C3C:  BTFSS  F9E.4
00C3E:  BRA    0C3C
00C40:  MOVWF  FAD
00C42:  MOVFF  39,FF6
00C46:  MOVFF  3A,FF7
00C4A:  DECFSZ 38,F
00C4C:  BRA    0C30
00C4E:  GOTO   0FCC (RETURN)
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
007AE:  CLRF   3F
007B0:  CLRF   3E
007B2:  CLRF   3D
007B4:  MOVLW  7F
007B6:  MOVWF  3C
007B8:  CLRF   43
007BA:  CLRF   42
007BC:  CLRF   41
007BE:  CLRF   40
007C0:  BSF    44.0
007C2:  BCF    44.1
007C4:  BCF    44.2
007C6:  CLRF   46
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
007C8:  MOVF   38,W
007CA:  IORWF  39,W
007CC:  BNZ   07D8
....................       return 0; 
007CE:  CLRF   00
007D0:  CLRF   01
007D2:  CLRF   02
007D4:  CLRF   03
007D6:  BRA    09DE
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
007D8:  MOVF   46,W
007DA:  INCF   46,F
007DC:  CLRF   03
007DE:  ADDWF  38,W
007E0:  MOVWF  FE9
007E2:  MOVF   39,W
007E4:  ADDWFC 03,W
007E6:  MOVWF  FEA
007E8:  MOVFF  FEF,45
007EC:  MOVF   45,F
007EE:  BTFSC  FD8.2
007F0:  BRA    0968
....................    { 
....................       if (skip && !isspace(c)) 
007F2:  BTFSS  44.0
007F4:  BRA    0814
007F6:  MOVF   45,W
007F8:  SUBLW  20
007FA:  BZ    0814
....................       { 
....................          skip = 0; 
007FC:  BCF    44.0
....................          if (c == '+') 
007FE:  MOVF   45,W
00800:  SUBLW  2B
00802:  BNZ   080A
....................          { 
....................             sign = 0; 
00804:  BCF    44.1
....................             continue; 
00806:  BRA    0952
....................          }             
00808:  BRA    0814
....................          else if (c == '-') 
0080A:  MOVF   45,W
0080C:  SUBLW  2D
0080E:  BNZ   0814
....................          { 
....................             sign = 1; 
00810:  BSF    44.1
....................             continue; 
00812:  BRA    0952
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
00814:  BTFSC  44.0
00816:  BRA    0826
00818:  MOVF   45,W
0081A:  SUBLW  2E
0081C:  BNZ   0826
0081E:  BTFSC  44.2
00820:  BRA    0826
....................          point = 1; 
00822:  BSF    44.2
00824:  BRA    0952
....................       else if (!skip && isdigit(c)) 
00826:  BTFSC  44.0
00828:  BRA    094C
0082A:  MOVF   45,W
0082C:  SUBLW  2F
0082E:  BTFSC  FD8.0
00830:  BRA    094C
00832:  MOVF   45,W
00834:  SUBLW  39
00836:  BTFSS  FD8.0
00838:  BRA    094C
....................       { 
....................          c -= '0'; 
0083A:  MOVLW  30
0083C:  SUBWF  45,F
....................          if (point) 
0083E:  BTFSS  44.2
00840:  BRA    08E0
....................          { 
....................             pow10 = pow10 * 10.0; 
00842:  MOVFF  3F,4A
00846:  MOVFF  3E,49
0084A:  MOVFF  3D,48
0084E:  MOVFF  3C,47
00852:  CLRF   4E
00854:  CLRF   4D
00856:  MOVLW  20
00858:  MOVWF  4C
0085A:  MOVLW  82
0085C:  MOVWF  4B
0085E:  RCALL  02C2
00860:  MOVFF  03,3F
00864:  MOVFF  02,3E
00868:  MOVFF  01,3D
0086C:  MOVFF  00,3C
....................             result += (float)c / pow10;    
00870:  CLRF   4C
00872:  MOVFF  45,4B
00876:  RCALL  03B4
00878:  MOVFF  03,4A
0087C:  MOVFF  02,49
00880:  MOVFF  01,48
00884:  MOVFF  00,47
00888:  MOVFF  03,4E
0088C:  MOVFF  02,4D
00890:  MOVFF  01,4C
00894:  MOVFF  00,4B
00898:  MOVFF  3F,52
0089C:  MOVFF  3E,51
008A0:  MOVFF  3D,50
008A4:  MOVFF  3C,4F
008A8:  RCALL  03EA
008AA:  BCF    FD8.1
008AC:  MOVFF  43,4E
008B0:  MOVFF  42,4D
008B4:  MOVFF  41,4C
008B8:  MOVFF  40,4B
008BC:  MOVFF  03,52
008C0:  MOVFF  02,51
008C4:  MOVFF  01,50
008C8:  MOVFF  00,4F
008CC:  RCALL  0544
008CE:  MOVFF  03,43
008D2:  MOVFF  02,42
008D6:  MOVFF  01,41
008DA:  MOVFF  00,40
....................          } 
008DE:  BRA    094A
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
008E0:  CLRF   4A
008E2:  CLRF   49
008E4:  MOVLW  20
008E6:  MOVWF  48
008E8:  MOVLW  82
008EA:  MOVWF  47
008EC:  MOVFF  43,4E
008F0:  MOVFF  42,4D
008F4:  MOVFF  41,4C
008F8:  MOVFF  40,4B
008FC:  RCALL  02C2
008FE:  MOVFF  03,4A
00902:  MOVFF  02,49
00906:  MOVFF  01,48
0090A:  MOVFF  00,47
0090E:  CLRF   4C
00910:  MOVFF  45,4B
00914:  RCALL  03B4
00916:  BCF    FD8.1
00918:  MOVFF  4A,4E
0091C:  MOVFF  49,4D
00920:  MOVFF  48,4C
00924:  MOVFF  47,4B
00928:  MOVFF  03,52
0092C:  MOVFF  02,51
00930:  MOVFF  01,50
00934:  MOVFF  00,4F
00938:  RCALL  0544
0093A:  MOVFF  03,43
0093E:  MOVFF  02,42
00942:  MOVFF  01,41
00946:  MOVFF  00,40
....................          } 
....................       } 
0094A:  BRA    0952
....................       else if (!skip) 
0094C:  BTFSC  44.0
0094E:  BRA    0952
....................          break; 
00950:  BRA    0968
00952:  MOVF   46,W
00954:  INCF   46,F
00956:  CLRF   03
00958:  ADDWF  38,W
0095A:  MOVWF  FE9
0095C:  MOVF   39,W
0095E:  ADDWFC 03,W
00960:  MOVWF  FEA
00962:  MOVFF  FEF,45
00966:  BRA    07EC
....................    } 
....................  
....................    if (sign) 
00968:  BTFSS  44.1
0096A:  BRA    099A
....................       result = -1*result; 
0096C:  CLRF   4A
0096E:  CLRF   49
00970:  MOVLW  80
00972:  MOVWF  48
00974:  MOVLW  7F
00976:  MOVWF  47
00978:  MOVFF  43,4E
0097C:  MOVFF  42,4D
00980:  MOVFF  41,4C
00984:  MOVFF  40,4B
00988:  RCALL  02C2
0098A:  MOVFF  03,43
0098E:  MOVFF  02,42
00992:  MOVFF  01,41
00996:  MOVFF  00,40
....................        
....................    if(endptr) 
0099A:  MOVF   3A,W
0099C:  IORWF  3B,W
0099E:  BZ    09CE
....................    { 
....................       if (ptr) { 
009A0:  MOVF   46,F
009A2:  BZ    09BC
....................          ptr--; 
009A4:  DECF   46,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
009A6:  MOVFF  3A,FE9
009AA:  MOVFF  3B,FEA
009AE:  MOVF   46,W
009B0:  ADDWF  38,W
009B2:  MOVWF  FEF
009B4:  MOVLW  00
009B6:  ADDWFC 39,W
009B8:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
009BA:  BRA    09CE
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
009BC:  MOVFF  3A,FE9
009C0:  MOVFF  3B,FEA
009C4:  MOVFF  39,FEC
009C8:  MOVF   FED,F
009CA:  MOVFF  38,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
009CE:  MOVFF  40,00
009D2:  MOVFF  41,01
009D6:  MOVFF  42,02
009DA:  MOVFF  43,03
009DE:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #fuses INTRC_IO, NOFCMEN, NOIESO, PUT, NOBROWNOUT, NOWDT  
.................... #fuses NOPBADEN, NOMCLR, STVREN, NOLVP, NODEBUG 
.................... #use delay(clock=16000000) 
.................... #use RS232(BAUD=9600,BITS=8,PARITY=N,XMIT=PIN_C6,RCV=PIN_C7,STOP=1)   
.................... #use standard_io(c) 
.................... #define tamanoBufer 11 
.................... //Variables globales 
.................... char Bufer[11]; 
.................... int datoMalo=0; 
.................... int posicion=0; 
.................... int terminadoRDA=0; 
.................... int timeOut=0; 
.................... #int_rda 
.................... void rda_isr() 
.................... {      
....................       Bufer[posicion]=getc(); 
*
00096:  CLRF   03
00098:  MOVF   28,W
0009A:  ADDLW  1C
0009C:  MOVWF  FE9
0009E:  MOVLW  00
000A0:  ADDWFC 03,W
000A2:  MOVWF  FEA
000A4:  BTFSS  F9E.5
000A6:  BRA    00A4
000A8:  MOVFF  FAE,FEF
....................       if(Bufer[posicion]==0x0A || Bufer[posicion]==0x0D)     //Si recivio enter 
000AC:  CLRF   03
000AE:  MOVF   28,W
000B0:  ADDLW  1C
000B2:  MOVWF  FE9
000B4:  MOVLW  00
000B6:  ADDWFC 03,W
000B8:  MOVWF  FEA
000BA:  MOVF   FEF,W
000BC:  SUBLW  0A
000BE:  BZ    00D4
000C0:  CLRF   03
000C2:  MOVF   28,W
000C4:  ADDLW  1C
000C6:  MOVWF  FE9
000C8:  MOVLW  00
000CA:  ADDWFC 03,W
000CC:  MOVWF  FEA
000CE:  MOVF   FEF,W
000D0:  SUBLW  0D
000D2:  BNZ   00D8
....................       { 
....................          terminadoRDA=1; 
000D4:  MOVLW  01
000D6:  MOVWF  29
....................       } 
....................       if(!(posicion<tamanoBufer-1))                         //Si no es menor de 9 (la ultima posicin del vector para escribir), activa bandera para que termine la interrupcin 
000D8:  MOVF   28,W
000DA:  SUBLW  09
000DC:  BC    00E2
....................       { 
....................          terminadoRDA=1; 
000DE:  MOVLW  01
000E0:  MOVWF  29
....................       } 
....................       if(((Bufer[posicion]<'0' && Bufer[posicion]>'9') && Bufer[posicion]!='-' && Bufer[posicion]!='.'))     //Si no ingreso un numero, un - o un .   El dato no es valido 
000E2:  CLRF   03
000E4:  MOVF   28,W
000E6:  ADDLW  1C
000E8:  MOVWF  FE9
000EA:  MOVLW  00
000EC:  ADDWFC 03,W
000EE:  MOVWF  FEA
000F0:  MOVF   FEF,W
000F2:  SUBLW  2F
000F4:  BNC   0136
000F6:  CLRF   03
000F8:  MOVF   28,W
000FA:  ADDLW  1C
000FC:  MOVWF  FE9
000FE:  MOVLW  00
00100:  ADDWFC 03,W
00102:  MOVWF  FEA
00104:  MOVF   FEF,W
00106:  SUBLW  39
00108:  BC    0136
0010A:  CLRF   03
0010C:  MOVF   28,W
0010E:  ADDLW  1C
00110:  MOVWF  FE9
00112:  MOVLW  00
00114:  ADDWFC 03,W
00116:  MOVWF  FEA
00118:  MOVF   FEF,W
0011A:  SUBLW  2D
0011C:  BZ    0136
0011E:  CLRF   03
00120:  MOVF   28,W
00122:  ADDLW  1C
00124:  MOVWF  FE9
00126:  MOVLW  00
00128:  ADDWFC 03,W
0012A:  MOVWF  FEA
0012C:  MOVF   FEF,W
0012E:  SUBLW  2E
00130:  BZ    0136
....................       { 
....................          datoMalo=1; 
00132:  MOVLW  01
00134:  MOVWF  27
....................       } 
....................       posicion++; 
00136:  INCF   28,F
....................  
00138:  BCF    F9E.5
0013A:  GOTO   0054
.................... } 
.................... void limpiarBufer(); 
.................... void main(void) 
*
00C52:  CLRF   FF8
00C54:  BCF    FD0.7
00C56:  BSF    07.7
00C58:  MOVLW  60
00C5A:  MOVWF  FD3
00C5C:  MOVLW  40
00C5E:  MOVWF  F9B
00C60:  MOVF   FD3,W
00C62:  BSF    FB8.3
00C64:  MOVLW  A0
00C66:  MOVWF  FAF
00C68:  MOVLW  01
00C6A:  MOVWF  FB0
00C6C:  MOVLW  A6
00C6E:  MOVWF  FAC
00C70:  MOVLW  90
00C72:  MOVWF  FAB
00C74:  CLRF   27
00C76:  CLRF   28
00C78:  CLRF   29
00C7A:  CLRF   2A
00C7C:  MOVF   FC1,W
00C7E:  ANDLW  C0
00C80:  IORLW  0F
00C82:  MOVWF  FC1
00C84:  MOVLW  07
00C86:  MOVWF  FB4
00C88:  CLRF   16
00C8A:  CLRF   17
.................... { 
....................    //Configuraciones del microcontrolador 
....................    setup_oscillator(OSC_16MHZ); 
00C8C:  MOVLW  60
00C8E:  MOVWF  FD3
00C90:  MOVLW  40
00C92:  MOVWF  F9B
00C94:  MOVF   FD3,W
....................    enable_interrupts(global); 
00C96:  MOVLW  C0
00C98:  IORWF  FF2,F
....................    enable_interrupts(int_rda); 
00C9A:  BSF    F9D.5
....................    SETUP_ADC_PORTS(NO_ANALOGS); 
00C9C:  MOVF   FC1,W
00C9E:  ANDLW  C0
00CA0:  IORLW  0F
00CA2:  MOVWF  FC1
....................    //Variables 
....................    inicio:   //Punto de retorno 
....................    float primerOperando=0, segundoOperando=0, resultado=0; 
....................    char operacion='0'; 
00CA4:  CLRF   2E
00CA6:  CLRF   2D
00CA8:  CLRF   2C
00CAA:  CLRF   2B
00CAC:  CLRF   32
00CAE:  CLRF   31
00CB0:  CLRF   30
00CB2:  CLRF   2F
00CB4:  CLRF   36
00CB6:  CLRF   35
00CB8:  CLRF   34
00CBA:  CLRF   33
00CBC:  MOVLW  30
00CBE:  MOVWF  37
....................    //// 
....................    while(true) 
....................    {    
....................       //Inicializamos variables a 0 y limpiamos Bufer 
....................       posicion=0; 
00CC0:  CLRF   28
....................       datoMalo=0; 
00CC2:  CLRF   27
....................       terminadoRDA=0; 
00CC4:  CLRF   29
....................       timeOut=0; 
00CC6:  CLRF   2A
....................       limpiarBufer(); 
00CC8:  CALL   0280
....................        
....................       printf("Practica No. 4\r"); 
00CCC:  MOVLW  3E
00CCE:  MOVWF  FF6
00CD0:  MOVLW  01
00CD2:  MOVWF  FF7
00CD4:  CALL   02A0
....................       printf("Calculadora Aritmetica \r\r"); 
00CD8:  MOVLW  4E
00CDA:  MOVWF  FF6
00CDC:  MOVLW  01
00CDE:  MOVWF  FF7
00CE0:  CALL   02A0
....................                                                   //primerOperando 
....................       printf("Ingresa el primer operando \r");    //Indica al usuario que ingrese el primer operando     
00CE4:  MOVLW  68
00CE6:  MOVWF  FF6
00CE8:  MOVLW  01
00CEA:  MOVWF  FF7
00CEC:  CALL   02A0
....................       While(terminadoRDA==0);                   //Mientras no aya terminado de recivir la trama se queda ciclado 
00CF0:  MOVF   29,F
00CF2:  BZ    0CF0
....................       if(datoMalo==1)                            //Si el dato ingresado no es correcto 
00CF4:  DECFSZ 27,W
00CF6:  BRA    0D16
....................       { 
....................          printf("Error \r"); 
00CF8:  MOVLW  86
00CFA:  MOVWF  FF6
00CFC:  MOVLW  01
00CFE:  MOVWF  FF7
00D00:  CALL   02A0
....................          if(timeOut==1) 
00D04:  DECFSZ 2A,W
00D06:  BRA    0D14
....................          { 
....................             printf("Se ha terminado el tiempo"); 
00D08:  MOVLW  8E
00D0A:  MOVWF  FF6
00D0C:  MOVLW  01
00D0E:  MOVWF  FF7
00D10:  CALL   02A0
....................          } 
....................          goto inicio; 
00D14:  BRA    0CA4
....................       } 
....................        if(Bufer[posicion-1]==0x0A || Bufer[posicion-1]==0x0D)     //Si la ultima tecla presionada fue enter, la hace igual a NULL 
00D16:  MOVLW  01
00D18:  SUBWF  28,W
00D1A:  CLRF   03
00D1C:  ADDLW  1C
00D1E:  MOVWF  FE9
00D20:  MOVLW  00
00D22:  ADDWFC 03,W
00D24:  MOVWF  FEA
00D26:  MOVF   FEF,W
00D28:  SUBLW  0A
00D2A:  BZ    0D42
00D2C:  MOVLW  01
00D2E:  SUBWF  28,W
00D30:  CLRF   03
00D32:  ADDLW  1C
00D34:  MOVWF  FE9
00D36:  MOVLW  00
00D38:  ADDWFC 03,W
00D3A:  MOVWF  FEA
00D3C:  MOVF   FEF,W
00D3E:  SUBLW  0D
00D40:  BNZ   0D54
....................       { 
....................          Bufer[posicion-1]=0; 
00D42:  MOVLW  01
00D44:  SUBWF  28,W
00D46:  CLRF   03
00D48:  ADDLW  1C
00D4A:  MOVWF  FE9
00D4C:  MOVLW  00
00D4E:  ADDWFC 03,W
00D50:  MOVWF  FEA
00D52:  CLRF   FEF
....................       } 
....................       primerOperando=atof(Bufer);                 //Asigna la cifra casteandola a un flotante, a primer operando en "primerOperando 
00D54:  CLRF   39
00D56:  MOVLW  1C
00D58:  MOVWF  38
00D5A:  CLRF   3B
00D5C:  CLRF   3A
00D5E:  RCALL  07AE
00D60:  MOVFF  03,2E
00D64:  MOVFF  02,2D
00D68:  MOVFF  01,2C
00D6C:  MOVFF  00,2B
....................       printf("%4.4f\r",primerOperando);              //Muestra el operando ingresado 
00D70:  MOVLW  89
00D72:  MOVWF  FE9
00D74:  MOVFF  2E,3B
00D78:  MOVFF  2D,3A
00D7C:  MOVFF  2C,39
00D80:  MOVFF  2B,38
00D84:  MOVLW  04
00D86:  MOVWF  3C
00D88:  RCALL  0AAE
00D8A:  MOVLW  0D
00D8C:  BTFSS  F9E.4
00D8E:  BRA    0D8C
00D90:  MOVWF  FAD
....................       posicion=0; 
00D92:  CLRF   28
....................       datoMalo=0; 
00D94:  CLRF   27
....................       terminadoRDA=0; 
00D96:  CLRF   29
....................       timeOut=0; 
00D98:  CLRF   2A
....................       limpiarBufer(); 
00D9A:  CALL   0280
....................                                                     //segundoOperando 
....................       printf("Ingresa el segundo operando \r");          //Indica al usuario que ingrese el segundo operando 
00D9E:  MOVLW  A8
00DA0:  MOVWF  FF6
00DA2:  MOVLW  01
00DA4:  MOVWF  FF7
00DA6:  CALL   02A0
....................       While(terminadoRDA==0);                   //Mientras no aya terminado de recivir la trama se queda ciclado 
00DAA:  MOVF   29,F
00DAC:  BZ    0DAA
....................       if(datoMalo==1)                            //Si el dato ingresado no es correcto 
00DAE:  DECFSZ 27,W
00DB0:  BRA    0DD0
....................       { 
....................          printf("Error \r"); 
00DB2:  MOVLW  C6
00DB4:  MOVWF  FF6
00DB6:  MOVLW  01
00DB8:  MOVWF  FF7
00DBA:  CALL   02A0
....................          if(timeOut==1) 
00DBE:  DECFSZ 2A,W
00DC0:  BRA    0DCE
....................          { 
....................             printf("Se ha terminado el tiempo"); 
00DC2:  MOVLW  CE
00DC4:  MOVWF  FF6
00DC6:  MOVLW  01
00DC8:  MOVWF  FF7
00DCA:  CALL   02A0
....................          } 
....................          goto inicio; 
00DCE:  BRA    0CA4
....................       } 
....................        if(Bufer[posicion-1]==0x0A || Bufer[posicion-1]==0x0D)     //Si la ultima tecla presionada fue enter, la hace igual a NULL 
00DD0:  MOVLW  01
00DD2:  SUBWF  28,W
00DD4:  CLRF   03
00DD6:  ADDLW  1C
00DD8:  MOVWF  FE9
00DDA:  MOVLW  00
00DDC:  ADDWFC 03,W
00DDE:  MOVWF  FEA
00DE0:  MOVF   FEF,W
00DE2:  SUBLW  0A
00DE4:  BZ    0DFC
00DE6:  MOVLW  01
00DE8:  SUBWF  28,W
00DEA:  CLRF   03
00DEC:  ADDLW  1C
00DEE:  MOVWF  FE9
00DF0:  MOVLW  00
00DF2:  ADDWFC 03,W
00DF4:  MOVWF  FEA
00DF6:  MOVF   FEF,W
00DF8:  SUBLW  0D
00DFA:  BNZ   0E0E
....................       { 
....................          Bufer[posicion-1]=0; 
00DFC:  MOVLW  01
00DFE:  SUBWF  28,W
00E00:  CLRF   03
00E02:  ADDLW  1C
00E04:  MOVWF  FE9
00E06:  MOVLW  00
00E08:  ADDWFC 03,W
00E0A:  MOVWF  FEA
00E0C:  CLRF   FEF
....................       } 
....................       segundoOperando=atof(Bufer);                    //Asigna la cifra casteandola a un flotante, a segundo operando en "segundoOperando" 
00E0E:  CLRF   39
00E10:  MOVLW  1C
00E12:  MOVWF  38
00E14:  CLRF   3B
00E16:  CLRF   3A
00E18:  RCALL  07AE
00E1A:  MOVFF  03,32
00E1E:  MOVFF  02,31
00E22:  MOVFF  01,30
00E26:  MOVFF  00,2F
....................       printf("%4.4f\r",segundoOperando);              //Muestra el operando ingresado 
00E2A:  MOVLW  89
00E2C:  MOVWF  FE9
00E2E:  MOVFF  32,3B
00E32:  MOVFF  31,3A
00E36:  MOVFF  30,39
00E3A:  MOVFF  2F,38
00E3E:  MOVLW  04
00E40:  MOVWF  3C
00E42:  RCALL  0AAE
00E44:  MOVLW  0D
00E46:  BTFSS  F9E.4
00E48:  BRA    0E46
00E4A:  MOVWF  FAD
....................       posicion=0; 
00E4C:  CLRF   28
....................       datoMalo=0; 
00E4E:  CLRF   27
....................       terminadoRDA=0; 
00E50:  CLRF   29
....................       timeOut=0; 
00E52:  CLRF   2A
....................       limpiarBufer(); 
00E54:  CALL   0280
....................        
....................                                                                  //Operacion 
....................       printf("Seleccione una operacion: \r 1)Suma  2)Resta  3)Multiplicacion  4)Division \r");    //Indica al usuario que selecione segun su nmero, una operacin  
00E58:  MOVLW  E8
00E5A:  MOVWF  FF6
00E5C:  MOVLW  01
00E5E:  MOVWF  FF7
00E60:  CALL   02A0
....................       While(terminadoRDA==0);                   //Mientras no aya terminado de recivir la trama se queda ciclado 
00E64:  MOVF   29,F
00E66:  BZ    0E64
....................       if(datoMalo==1)                            //Si el dato ingresado no es correcto 
00E68:  DECFSZ 27,W
00E6A:  BRA    0E8A
....................       { 
....................          printf("Error \r"); 
00E6C:  MOVLW  34
00E6E:  MOVWF  FF6
00E70:  MOVLW  02
00E72:  MOVWF  FF7
00E74:  CALL   02A0
....................          if(timeOut==1) 
00E78:  DECFSZ 2A,W
00E7A:  BRA    0E88
....................          { 
....................             printf("Se ha terminado el tiempo"); 
00E7C:  MOVLW  3C
00E7E:  MOVWF  FF6
00E80:  MOVLW  02
00E82:  MOVWF  FF7
00E84:  CALL   02A0
....................          } 
....................          goto inicio; 
00E88:  BRA    0CA4
....................       } 
....................        if(Bufer[posicion-1]==0x0A || Bufer[posicion-1]==0x0D)     //Si la ultima tecla presionada fue enter, la hace igual a NULL 
00E8A:  MOVLW  01
00E8C:  SUBWF  28,W
00E8E:  CLRF   03
00E90:  ADDLW  1C
00E92:  MOVWF  FE9
00E94:  MOVLW  00
00E96:  ADDWFC 03,W
00E98:  MOVWF  FEA
00E9A:  MOVF   FEF,W
00E9C:  SUBLW  0A
00E9E:  BZ    0EB6
00EA0:  MOVLW  01
00EA2:  SUBWF  28,W
00EA4:  CLRF   03
00EA6:  ADDLW  1C
00EA8:  MOVWF  FE9
00EAA:  MOVLW  00
00EAC:  ADDWFC 03,W
00EAE:  MOVWF  FEA
00EB0:  MOVF   FEF,W
00EB2:  SUBLW  0D
00EB4:  BNZ   0EC8
....................       { 
....................          Bufer[posicion-1]=0; 
00EB6:  MOVLW  01
00EB8:  SUBWF  28,W
00EBA:  CLRF   03
00EBC:  ADDLW  1C
00EBE:  MOVWF  FE9
00EC0:  MOVLW  00
00EC2:  ADDWFC 03,W
00EC4:  MOVWF  FEA
00EC6:  CLRF   FEF
....................       } 
....................       operacion=Bufer[0];                      //Asigna la operacin casteandola a un flotante, a operacion 
00EC8:  MOVFF  1C,37
....................    
....................       //Saca resultado con los dos operadores ingresados y deacuerdo a la operacin seleccionada 
....................       if(operacion=='1')   resultado=primerOperando+segundoOperando;          //suma 
00ECC:  MOVF   37,W
00ECE:  SUBLW  31
00ED0:  BNZ   0F0A
00ED2:  BCF    FD8.1
00ED4:  MOVFF  2E,4E
00ED8:  MOVFF  2D,4D
00EDC:  MOVFF  2C,4C
00EE0:  MOVFF  2B,4B
00EE4:  MOVFF  32,52
00EE8:  MOVFF  31,51
00EEC:  MOVFF  30,50
00EF0:  MOVFF  2F,4F
00EF4:  CALL   0544
00EF8:  MOVFF  03,36
00EFC:  MOVFF  02,35
00F00:  MOVFF  01,34
00F04:  MOVFF  00,33
00F08:  BRA    0FBE
....................       else if(operacion=='2')   resultado=primerOperando-segundoOperando;     //resta 
00F0A:  MOVF   37,W
00F0C:  SUBLW  32
00F0E:  BNZ   0F48
00F10:  BSF    FD8.1
00F12:  MOVFF  2E,4E
00F16:  MOVFF  2D,4D
00F1A:  MOVFF  2C,4C
00F1E:  MOVFF  2B,4B
00F22:  MOVFF  32,52
00F26:  MOVFF  31,51
00F2A:  MOVFF  30,50
00F2E:  MOVFF  2F,4F
00F32:  CALL   0544
00F36:  MOVFF  03,36
00F3A:  MOVFF  02,35
00F3E:  MOVFF  01,34
00F42:  MOVFF  00,33
00F46:  BRA    0FBE
....................       else if(operacion=='3')   resultado=primerOperando*segundoOperando;     //multiplicacion 
00F48:  MOVF   37,W
00F4A:  SUBLW  33
00F4C:  BNZ   0F84
00F4E:  MOVFF  2E,4A
00F52:  MOVFF  2D,49
00F56:  MOVFF  2C,48
00F5A:  MOVFF  2B,47
00F5E:  MOVFF  32,4E
00F62:  MOVFF  31,4D
00F66:  MOVFF  30,4C
00F6A:  MOVFF  2F,4B
00F6E:  CALL   02C2
00F72:  MOVFF  03,36
00F76:  MOVFF  02,35
00F7A:  MOVFF  01,34
00F7E:  MOVFF  00,33
00F82:  BRA    0FBE
....................       else if(operacion=='4')   resultado=primerOperando/segundoOperando;     //divicion 
00F84:  MOVF   37,W
00F86:  SUBLW  34
00F88:  BNZ   0FBE
00F8A:  MOVFF  2E,4E
00F8E:  MOVFF  2D,4D
00F92:  MOVFF  2C,4C
00F96:  MOVFF  2B,4B
00F9A:  MOVFF  32,52
00F9E:  MOVFF  31,51
00FA2:  MOVFF  30,50
00FA6:  MOVFF  2F,4F
00FAA:  CALL   03EA
00FAE:  MOVFF  03,36
00FB2:  MOVFF  02,35
00FB6:  MOVFF  01,34
00FBA:  MOVFF  00,33
....................       //Muestra resultado 
....................       printf("El resultado de la operacion es: %4.4f\r\r",resultado); 
00FBE:  MOVLW  56
00FC0:  MOVWF  FF6
00FC2:  MOVLW  02
00FC4:  MOVWF  FF7
00FC6:  MOVLW  21
00FC8:  MOVWF  38
00FCA:  BRA    0C30
00FCC:  MOVLW  89
00FCE:  MOVWF  FE9
00FD0:  MOVFF  36,3B
00FD4:  MOVFF  35,3A
00FD8:  MOVFF  34,39
00FDC:  MOVFF  33,38
00FE0:  MOVLW  04
00FE2:  MOVWF  3C
00FE4:  RCALL  0AAE
00FE6:  MOVLW  0D
00FE8:  BTFSS  F9E.4
00FEA:  BRA    0FE8
00FEC:  MOVWF  FAD
00FEE:  MOVLW  0D
00FF0:  BTFSS  F9E.4
00FF2:  BRA    0FF0
00FF4:  MOVWF  FAD
00FF6:  BRA    0CC0
....................    }  
.................... } 
.................... void limpiarBufer() 
*
00280:  CLRF   38
*
00FF8:  SLEEP 
.................... { 
....................    int i=0; 
....................    for(i=0; i<tamanoBufer; i++) 
*
00282:  CLRF   38
00284:  MOVF   38,W
00286:  SUBLW  0A
00288:  BNC   029E
....................    { 
....................       Bufer[i]=0; 
0028A:  CLRF   03
0028C:  MOVF   38,W
0028E:  ADDLW  1C
00290:  MOVWF  FE9
00292:  MOVLW  00
00294:  ADDWFC 03,W
00296:  MOVWF  FEA
00298:  CLRF   FEF
0029A:  INCF   38,F
0029C:  BRA    0284
....................    } 
0029E:  RETURN 0
.................... } 

Configuration Fuses:
   Word  1: 0800   INTRC_IO NOFCMEN NOIESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 0500   CCP2C1 NOPBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
