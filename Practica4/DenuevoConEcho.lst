CCS PCH C Compiler, Version 5.012, 41559               27-abr.-17 00:27

               Filename:   C:\Users\luis\Documents\4Semestre\Embebidos\SystemasEmbebidos4G\Practica4\DenuevoConEcho.lst

               ROM used:   4474 bytes (7%)
                           Largest free fragment is 61058
               RAM used:   48 (1%) at main() level
                           96 (2%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   0D5E
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   01AE
00054:  BTFSS  F9D.5
00056:  GOTO   0060
0005A:  BTFSC  F9E.5
0005C:  GOTO   00A2
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVF   04,W
00098:  MOVFF  06,FE0
0009C:  MOVFF  05,FD8
000A0:  RETFIE 0
.................... #include <18F4620.h> 
.................... ///////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
*
001D2:  DATA 50,72
001D4:  DATA 61,63
001D6:  DATA 74,69
001D8:  DATA 63,61
001DA:  DATA 20,4E
001DC:  DATA 6F,2E
001DE:  DATA 20,34
001E0:  DATA 0D,00
001E2:  DATA 43,61
001E4:  DATA 6C,63
001E6:  DATA 75,6C
001E8:  DATA 61,64
001EA:  DATA 6F,72
001EC:  DATA 61,20
001EE:  DATA 41,72
001F0:  DATA 69,74
001F2:  DATA 6D,65
001F4:  DATA 74,69
001F6:  DATA 63,61
001F8:  DATA 20,0D
001FA:  DATA 0D,00
001FC:  DATA 49,6E
001FE:  DATA 67,72
00200:  DATA 65,73
00202:  DATA 61,20
00204:  DATA 65,6C
00206:  DATA 20,70
00208:  DATA 72,69
0020A:  DATA 6D,65
0020C:  DATA 72,20
0020E:  DATA 6F,70
00210:  DATA 65,72
00212:  DATA 61,6E
00214:  DATA 64,6F
00216:  DATA 20,0D
00218:  DATA 00,00
0021A:  DATA 45,72
0021C:  DATA 72,6F
0021E:  DATA 72,20
00220:  DATA 0D,0D
00222:  DATA 00,00
00224:  DATA 53,65
00226:  DATA 20,68
00228:  DATA 61,20
0022A:  DATA 74,65
0022C:  DATA 72,6D
0022E:  DATA 69,6E
00230:  DATA 61,64
00232:  DATA 6F,20
00234:  DATA 65,6C
00236:  DATA 20,74
00238:  DATA 69,65
0023A:  DATA 6D,70
0023C:  DATA 6F,20
0023E:  DATA 0D,0D
00240:  DATA 00,00
00242:  DATA 49,6E
00244:  DATA 67,72
00246:  DATA 65,73
00248:  DATA 61,20
0024A:  DATA 65,6C
0024C:  DATA 20,73
0024E:  DATA 65,67
00250:  DATA 75,6E
00252:  DATA 64,6F
00254:  DATA 20,6F
00256:  DATA 70,65
00258:  DATA 72,61
0025A:  DATA 6E,64
0025C:  DATA 6F,20
0025E:  DATA 0D,00
00260:  DATA 45,72
00262:  DATA 72,6F
00264:  DATA 72,20
00266:  DATA 0D,00
00268:  DATA 53,65
0026A:  DATA 20,68
0026C:  DATA 61,20
0026E:  DATA 74,65
00270:  DATA 72,6D
00272:  DATA 69,6E
00274:  DATA 61,64
00276:  DATA 6F,20
00278:  DATA 65,6C
0027A:  DATA 20,74
0027C:  DATA 69,65
0027E:  DATA 6D,70
00280:  DATA 6F,00
00282:  DATA 53,65
00284:  DATA 6C,65
00286:  DATA 63,63
00288:  DATA 69,6F
0028A:  DATA 6E,65
0028C:  DATA 20,75
0028E:  DATA 6E,61
00290:  DATA 20,6F
00292:  DATA 70,65
00294:  DATA 72,61
00296:  DATA 63,69
00298:  DATA 6F,6E
0029A:  DATA 3A,20
0029C:  DATA 0D,20
0029E:  DATA 31,29
002A0:  DATA 53,75
002A2:  DATA 6D,61
002A4:  DATA 20,20
002A6:  DATA 32,29
002A8:  DATA 52,65
002AA:  DATA 73,74
002AC:  DATA 61,20
002AE:  DATA 20,33
002B0:  DATA 29,4D
002B2:  DATA 75,6C
002B4:  DATA 74,69
002B6:  DATA 70,6C
002B8:  DATA 69,63
002BA:  DATA 61,63
002BC:  DATA 69,6F
002BE:  DATA 6E,20
002C0:  DATA 20,34
002C2:  DATA 29,44
002C4:  DATA 69,76
002C6:  DATA 69,73
002C8:  DATA 69,6F
002CA:  DATA 6E,20
002CC:  DATA 0D,00
002CE:  DATA 45,72
002D0:  DATA 72,6F
002D2:  DATA 72,20
002D4:  DATA 0D,00
002D6:  DATA 53,65
002D8:  DATA 20,68
002DA:  DATA 61,20
002DC:  DATA 74,65
002DE:  DATA 72,6D
002E0:  DATA 69,6E
002E2:  DATA 61,64
002E4:  DATA 6F,20
002E6:  DATA 65,6C
002E8:  DATA 20,74
002EA:  DATA 69,65
002EC:  DATA 6D,70
002EE:  DATA 6F,00
002F0:  DATA 45,6C
002F2:  DATA 20,72
002F4:  DATA 65,73
002F6:  DATA 75,6C
002F8:  DATA 74,61
002FA:  DATA 64,6F
002FC:  DATA 20,64
002FE:  DATA 65,20
00300:  DATA 6C,61
00302:  DATA 20,6F
00304:  DATA 70,65
00306:  DATA 72,61
00308:  DATA 63,69
0030A:  DATA 6F,6E
0030C:  DATA 20,65
0030E:  DATA 73,3A
00310:  DATA 20,25
00312:  DATA 66,0D
00314:  DATA 0D,00
*
00336:  TBLRD*+
00338:  MOVF   FF5,F
0033A:  BZ    0356
0033C:  MOVFF  FF6,3B
00340:  MOVFF  FF7,3C
00344:  MOVF   FF5,W
00346:  BTFSS  F9E.4
00348:  BRA    0346
0034A:  MOVWF  FAD
0034C:  MOVFF  3B,FF6
00350:  MOVFF  3C,FF7
00354:  BRA    0336
00356:  RETURN 0
00358:  MOVF   4A,W
0035A:  BTFSC  FD8.2
0035C:  BRA    0440
0035E:  MOVWF  00
00360:  MOVF   4E,W
00362:  BTFSC  FD8.2
00364:  BRA    0440
00366:  ADDWF  00,F
00368:  BNC   0372
0036A:  MOVLW  81
0036C:  ADDWF  00,F
0036E:  BC    0440
00370:  BRA    037A
00372:  MOVLW  7F
00374:  SUBWF  00,F
00376:  BNC   0440
00378:  BZ    0440
0037A:  MOVFF  4B,52
0037E:  MOVF   4F,W
00380:  XORWF  52,F
00382:  BSF    4B.7
00384:  BSF    4F.7
00386:  MOVF   4D,W
00388:  MULWF  51
0038A:  MOVFF  FF4,54
0038E:  MOVF   4C,W
00390:  MULWF  50
00392:  MOVFF  FF4,03
00396:  MOVFF  FF3,53
0039A:  MULWF  51
0039C:  MOVF   FF3,W
0039E:  ADDWF  54,F
003A0:  MOVF   FF4,W
003A2:  ADDWFC 53,F
003A4:  MOVLW  00
003A6:  ADDWFC 03,F
003A8:  MOVF   4D,W
003AA:  MULWF  50
003AC:  MOVF   FF3,W
003AE:  ADDWF  54,F
003B0:  MOVF   FF4,W
003B2:  ADDWFC 53,F
003B4:  MOVLW  00
003B6:  CLRF   02
003B8:  ADDWFC 03,F
003BA:  ADDWFC 02,F
003BC:  MOVF   4B,W
003BE:  MULWF  51
003C0:  MOVF   FF3,W
003C2:  ADDWF  53,F
003C4:  MOVF   FF4,W
003C6:  ADDWFC 03,F
003C8:  MOVLW  00
003CA:  ADDWFC 02,F
003CC:  MOVF   4B,W
003CE:  MULWF  50
003D0:  MOVF   FF3,W
003D2:  ADDWF  03,F
003D4:  MOVF   FF4,W
003D6:  ADDWFC 02,F
003D8:  MOVLW  00
003DA:  CLRF   01
003DC:  ADDWFC 01,F
003DE:  MOVF   4D,W
003E0:  MULWF  4F
003E2:  MOVF   FF3,W
003E4:  ADDWF  53,F
003E6:  MOVF   FF4,W
003E8:  ADDWFC 03,F
003EA:  MOVLW  00
003EC:  ADDWFC 02,F
003EE:  ADDWFC 01,F
003F0:  MOVF   4C,W
003F2:  MULWF  4F
003F4:  MOVF   FF3,W
003F6:  ADDWF  03,F
003F8:  MOVF   FF4,W
003FA:  ADDWFC 02,F
003FC:  MOVLW  00
003FE:  ADDWFC 01,F
00400:  MOVF   4B,W
00402:  MULWF  4F
00404:  MOVF   FF3,W
00406:  ADDWF  02,F
00408:  MOVF   FF4,W
0040A:  ADDWFC 01,F
0040C:  INCF   00,F
0040E:  BTFSC  01.7
00410:  BRA    041C
00412:  RLCF   53,F
00414:  RLCF   03,F
00416:  RLCF   02,F
00418:  RLCF   01,F
0041A:  DECF   00,F
0041C:  MOVLW  00
0041E:  BTFSS  53.7
00420:  BRA    0436
00422:  INCF   03,F
00424:  ADDWFC 02,F
00426:  ADDWFC 01,F
00428:  MOVF   01,W
0042A:  BNZ   0436
0042C:  MOVF   02,W
0042E:  BNZ   0436
00430:  MOVF   03,W
00432:  BNZ   0436
00434:  INCF   00,F
00436:  BTFSC  52.7
00438:  BSF    01.7
0043A:  BTFSS  52.7
0043C:  BCF    01.7
0043E:  BRA    0448
00440:  CLRF   00
00442:  CLRF   01
00444:  CLRF   02
00446:  CLRF   03
00448:  RETURN 0
0044A:  MOVLW  8E
0044C:  MOVWF  00
0044E:  MOVFF  4F,01
00452:  MOVFF  4E,02
00456:  CLRF   03
00458:  MOVF   01,F
0045A:  BNZ   046E
0045C:  MOVFF  02,01
00460:  CLRF   02
00462:  MOVLW  08
00464:  SUBWF  00,F
00466:  MOVF   01,F
00468:  BNZ   046E
0046A:  CLRF   00
0046C:  BRA    047E
0046E:  BCF    FD8.0
00470:  BTFSC  01.7
00472:  BRA    047C
00474:  RLCF   02,F
00476:  RLCF   01,F
00478:  DECF   00,F
0047A:  BRA    046E
0047C:  BCF    01.7
0047E:  RETURN 0
00480:  MOVF   4E,W
00482:  BTFSC  FD8.2
00484:  BRA    05D0
00486:  MOVWF  5A
00488:  MOVF   52,W
0048A:  BTFSC  FD8.2
0048C:  BRA    05D0
0048E:  SUBWF  5A,F
00490:  BNC   049C
00492:  MOVLW  7F
00494:  ADDWF  5A,F
00496:  BTFSC  FD8.0
00498:  BRA    05D0
0049A:  BRA    04A8
0049C:  MOVLW  81
0049E:  SUBWF  5A,F
004A0:  BTFSS  FD8.0
004A2:  BRA    05D0
004A4:  BTFSC  FD8.2
004A6:  BRA    05D0
004A8:  MOVFF  5A,00
004AC:  CLRF   01
004AE:  CLRF   02
004B0:  CLRF   03
004B2:  CLRF   59
004B4:  MOVFF  4F,58
004B8:  BSF    58.7
004BA:  MOVFF  50,57
004BE:  MOVFF  51,56
004C2:  MOVLW  19
004C4:  MOVWF  5A
004C6:  MOVF   55,W
004C8:  SUBWF  56,F
004CA:  BC    04E6
004CC:  MOVLW  01
004CE:  SUBWF  57,F
004D0:  BC    04E6
004D2:  SUBWF  58,F
004D4:  BC    04E6
004D6:  SUBWF  59,F
004D8:  BC    04E6
004DA:  INCF   59,F
004DC:  INCF   58,F
004DE:  INCF   57,F
004E0:  MOVF   55,W
004E2:  ADDWF  56,F
004E4:  BRA    0536
004E6:  MOVF   54,W
004E8:  SUBWF  57,F
004EA:  BC    0510
004EC:  MOVLW  01
004EE:  SUBWF  58,F
004F0:  BC    0510
004F2:  SUBWF  59,F
004F4:  BC    0510
004F6:  INCF   59,F
004F8:  INCF   58,F
004FA:  MOVF   54,W
004FC:  ADDWF  57,F
004FE:  MOVF   55,W
00500:  ADDWF  56,F
00502:  BNC   0536
00504:  INCF   57,F
00506:  BNZ   0536
00508:  INCF   58,F
0050A:  BNZ   0536
0050C:  INCF   59,F
0050E:  BRA    0536
00510:  MOVF   53,W
00512:  IORLW  80
00514:  SUBWF  58,F
00516:  BC    0534
00518:  MOVLW  01
0051A:  SUBWF  59,F
0051C:  BC    0534
0051E:  INCF   59,F
00520:  MOVF   53,W
00522:  IORLW  80
00524:  ADDWF  58,F
00526:  MOVF   54,W
00528:  ADDWF  57,F
0052A:  BNC   04FE
0052C:  INCF   58,F
0052E:  BNZ   04FE
00530:  INCF   59,F
00532:  BRA    04FE
00534:  BSF    03.0
00536:  DECFSZ 5A,F
00538:  BRA    053C
0053A:  BRA    0552
0053C:  BCF    FD8.0
0053E:  RLCF   56,F
00540:  RLCF   57,F
00542:  RLCF   58,F
00544:  RLCF   59,F
00546:  BCF    FD8.0
00548:  RLCF   03,F
0054A:  RLCF   02,F
0054C:  RLCF   01,F
0054E:  RLCF   5B,F
00550:  BRA    04C6
00552:  BTFSS  5B.0
00554:  BRA    0562
00556:  BCF    FD8.0
00558:  RRCF   01,F
0055A:  RRCF   02,F
0055C:  RRCF   03,F
0055E:  RRCF   5B,F
00560:  BRA    0566
00562:  DECF   00,F
00564:  BZ    05D0
00566:  BTFSC  5B.7
00568:  BRA    05A6
0056A:  BCF    FD8.0
0056C:  RLCF   56,F
0056E:  RLCF   57,F
00570:  RLCF   58,F
00572:  RLCF   59,F
00574:  MOVF   55,W
00576:  SUBWF  56,F
00578:  BC    0588
0057A:  MOVLW  01
0057C:  SUBWF  57,F
0057E:  BC    0588
00580:  SUBWF  58,F
00582:  BC    0588
00584:  SUBWF  59,F
00586:  BNC   05BC
00588:  MOVF   54,W
0058A:  SUBWF  57,F
0058C:  BC    0598
0058E:  MOVLW  01
00590:  SUBWF  58,F
00592:  BC    0598
00594:  SUBWF  59,F
00596:  BNC   05BC
00598:  MOVF   53,W
0059A:  IORLW  80
0059C:  SUBWF  58,F
0059E:  BC    05A6
005A0:  MOVLW  01
005A2:  SUBWF  59,F
005A4:  BNC   05BC
005A6:  INCF   03,F
005A8:  BNZ   05BC
005AA:  INCF   02,F
005AC:  BNZ   05BC
005AE:  INCF   01,F
005B0:  BNZ   05BC
005B2:  INCF   00,F
005B4:  BZ    05D0
005B6:  RRCF   01,F
005B8:  RRCF   02,F
005BA:  RRCF   03,F
005BC:  MOVFF  4F,5A
005C0:  MOVF   53,W
005C2:  XORWF  5A,F
005C4:  BTFSS  5A.7
005C6:  BRA    05CC
005C8:  BSF    01.7
005CA:  BRA    05D8
005CC:  BCF    01.7
005CE:  BRA    05D8
005D0:  CLRF   00
005D2:  CLRF   01
005D4:  CLRF   02
005D6:  CLRF   03
005D8:  RETURN 0
005DA:  MOVLW  80
005DC:  BTFSC  FD8.1
005DE:  XORWF  53,F
005E0:  CLRF   58
005E2:  CLRF   59
005E4:  MOVFF  4F,57
005E8:  MOVF   53,W
005EA:  XORWF  57,F
005EC:  MOVF   4E,W
005EE:  BTFSC  FD8.2
005F0:  BRA    07AA
005F2:  MOVWF  56
005F4:  MOVWF  00
005F6:  MOVF   52,W
005F8:  BTFSC  FD8.2
005FA:  BRA    07BC
005FC:  SUBWF  56,F
005FE:  BTFSC  FD8.2
00600:  BRA    0704
00602:  BNC   067E
00604:  MOVFF  53,5C
00608:  BSF    5C.7
0060A:  MOVFF  54,5B
0060E:  MOVFF  55,5A
00612:  CLRF   59
00614:  BCF    FD8.0
00616:  RRCF   5C,F
00618:  RRCF   5B,F
0061A:  RRCF   5A,F
0061C:  RRCF   59,F
0061E:  DECFSZ 56,F
00620:  BRA    0612
00622:  BTFSS  57.7
00624:  BRA    062C
00626:  BSF    58.0
00628:  BRA    07E4
0062A:  BCF    58.0
0062C:  BCF    56.0
0062E:  BSF    58.4
00630:  CLRF   FEA
00632:  MOVLW  51
00634:  MOVWF  FE9
00636:  BRA    080A
00638:  BCF    58.4
0063A:  BTFSC  57.7
0063C:  BRA    0652
0063E:  BTFSS  56.0
00640:  BRA    0668
00642:  RRCF   5C,F
00644:  RRCF   5B,F
00646:  RRCF   5A,F
00648:  RRCF   59,F
0064A:  INCF   00,F
0064C:  BTFSC  FD8.2
0064E:  BRA    07DA
00650:  BRA    0668
00652:  BTFSC  5C.7
00654:  BRA    066E
00656:  BCF    FD8.0
00658:  RLCF   59,F
0065A:  RLCF   5A,F
0065C:  RLCF   5B,F
0065E:  RLCF   5C,F
00660:  DECF   00,F
00662:  BTFSC  FD8.2
00664:  BRA    07DA
00666:  BRA    0652
00668:  BSF    58.6
0066A:  BRA    0742
0066C:  BCF    58.6
0066E:  MOVFF  4F,57
00672:  BTFSS  4F.7
00674:  BRA    067A
00676:  BSF    5C.7
00678:  BRA    07CC
0067A:  BCF    5C.7
0067C:  BRA    07CC
0067E:  MOVFF  52,56
00682:  MOVFF  52,00
00686:  MOVF   4E,W
00688:  SUBWF  56,F
0068A:  MOVFF  4F,5C
0068E:  BSF    5C.7
00690:  MOVFF  50,5B
00694:  MOVFF  51,5A
00698:  CLRF   59
0069A:  BCF    FD8.0
0069C:  RRCF   5C,F
0069E:  RRCF   5B,F
006A0:  RRCF   5A,F
006A2:  RRCF   59,F
006A4:  DECFSZ 56,F
006A6:  BRA    0698
006A8:  BTFSS  57.7
006AA:  BRA    06B2
006AC:  BSF    58.1
006AE:  BRA    07E4
006B0:  BCF    58.1
006B2:  BCF    56.0
006B4:  BSF    58.5
006B6:  CLRF   FEA
006B8:  MOVLW  55
006BA:  MOVWF  FE9
006BC:  BRA    080A
006BE:  BCF    58.5
006C0:  BTFSC  57.7
006C2:  BRA    06D8
006C4:  BTFSS  56.0
006C6:  BRA    06EE
006C8:  RRCF   5C,F
006CA:  RRCF   5B,F
006CC:  RRCF   5A,F
006CE:  RRCF   59,F
006D0:  INCF   00,F
006D2:  BTFSC  FD8.2
006D4:  BRA    07DA
006D6:  BRA    06EE
006D8:  BTFSC  5C.7
006DA:  BRA    06F4
006DC:  BCF    FD8.0
006DE:  RLCF   59,F
006E0:  RLCF   5A,F
006E2:  RLCF   5B,F
006E4:  RLCF   5C,F
006E6:  DECF   00,F
006E8:  BTFSC  FD8.2
006EA:  BRA    07DA
006EC:  BRA    06D8
006EE:  BSF    58.7
006F0:  BRA    0742
006F2:  BCF    58.7
006F4:  MOVFF  53,57
006F8:  BTFSS  53.7
006FA:  BRA    0700
006FC:  BSF    5C.7
006FE:  BRA    07CC
00700:  BCF    5C.7
00702:  BRA    07CC
00704:  MOVFF  53,5C
00708:  BSF    5C.7
0070A:  MOVFF  54,5B
0070E:  MOVFF  55,5A
00712:  BTFSS  57.7
00714:  BRA    071E
00716:  BCF    5C.7
00718:  BSF    58.2
0071A:  BRA    07E4
0071C:  BCF    58.2
0071E:  CLRF   59
00720:  BCF    56.0
00722:  CLRF   FEA
00724:  MOVLW  51
00726:  MOVWF  FE9
00728:  BRA    080A
0072A:  BTFSC  57.7
0072C:  BRA    0766
0072E:  MOVFF  4F,57
00732:  BTFSS  56.0
00734:  BRA    0742
00736:  RRCF   5C,F
00738:  RRCF   5B,F
0073A:  RRCF   5A,F
0073C:  RRCF   59,F
0073E:  INCF   00,F
00740:  BZ    07DA
00742:  BTFSS  59.7
00744:  BRA    075C
00746:  INCF   5A,F
00748:  BNZ   075C
0074A:  INCF   5B,F
0074C:  BNZ   075C
0074E:  INCF   5C,F
00750:  BNZ   075C
00752:  RRCF   5C,F
00754:  RRCF   5B,F
00756:  RRCF   5A,F
00758:  INCF   00,F
0075A:  BZ    07DA
0075C:  BTFSC  58.6
0075E:  BRA    066C
00760:  BTFSC  58.7
00762:  BRA    06F2
00764:  BRA    079E
00766:  MOVLW  80
00768:  XORWF  5C,F
0076A:  BTFSS  5C.7
0076C:  BRA    0776
0076E:  BRA    07E4
00770:  MOVFF  53,57
00774:  BRA    078A
00776:  MOVFF  4F,57
0077A:  MOVF   5C,F
0077C:  BNZ   078A
0077E:  MOVF   5B,F
00780:  BNZ   078A
00782:  MOVF   5A,F
00784:  BNZ   078A
00786:  CLRF   00
00788:  BRA    07CC
0078A:  BTFSC  5C.7
0078C:  BRA    079E
0078E:  BCF    FD8.0
00790:  RLCF   59,F
00792:  RLCF   5A,F
00794:  RLCF   5B,F
00796:  RLCF   5C,F
00798:  DECFSZ 00,F
0079A:  BRA    078A
0079C:  BRA    07DA
0079E:  BTFSS  57.7
007A0:  BRA    07A6
007A2:  BSF    5C.7
007A4:  BRA    07CC
007A6:  BCF    5C.7
007A8:  BRA    07CC
007AA:  MOVFF  52,00
007AE:  MOVFF  53,5C
007B2:  MOVFF  54,5B
007B6:  MOVFF  55,5A
007BA:  BRA    07CC
007BC:  MOVFF  4E,00
007C0:  MOVFF  4F,5C
007C4:  MOVFF  50,5B
007C8:  MOVFF  51,5A
007CC:  MOVFF  5C,01
007D0:  MOVFF  5B,02
007D4:  MOVFF  5A,03
007D8:  BRA    0842
007DA:  CLRF   00
007DC:  CLRF   01
007DE:  CLRF   02
007E0:  CLRF   03
007E2:  BRA    0842
007E4:  CLRF   59
007E6:  COMF   5A,F
007E8:  COMF   5B,F
007EA:  COMF   5C,F
007EC:  COMF   59,F
007EE:  INCF   59,F
007F0:  BNZ   07FC
007F2:  INCF   5A,F
007F4:  BNZ   07FC
007F6:  INCF   5B,F
007F8:  BNZ   07FC
007FA:  INCF   5C,F
007FC:  BTFSC  58.0
007FE:  BRA    062A
00800:  BTFSC  58.1
00802:  BRA    06B0
00804:  BTFSC  58.2
00806:  BRA    071C
00808:  BRA    0770
0080A:  MOVF   FEF,W
0080C:  ADDWF  5A,F
0080E:  BNC   081A
00810:  INCF   5B,F
00812:  BNZ   081A
00814:  INCF   5C,F
00816:  BTFSC  FD8.2
00818:  BSF    56.0
0081A:  MOVF   FED,F
0081C:  MOVF   FEF,W
0081E:  ADDWF  5B,F
00820:  BNC   0828
00822:  INCF   5C,F
00824:  BTFSC  FD8.2
00826:  BSF    56.0
00828:  MOVF   FED,F
0082A:  MOVF   FEF,W
0082C:  BTFSC  FEF.7
0082E:  BRA    0832
00830:  XORLW  80
00832:  ADDWF  5C,F
00834:  BTFSC  FD8.0
00836:  BSF    56.0
00838:  BTFSC  58.4
0083A:  BRA    0638
0083C:  BTFSC  58.5
0083E:  BRA    06BE
00840:  BRA    072A
00842:  RETURN 0
*
00A76:  MOVFF  3C,43
00A7A:  MOVF   40,W
00A7C:  XORWF  43,F
00A7E:  BTFSS  43.7
00A80:  BRA    0A8C
00A82:  BCF    FD8.2
00A84:  BCF    FD8.0
00A86:  BTFSC  3C.7
00A88:  BSF    FD8.0
00A8A:  BRA    0AEA
00A8C:  MOVFF  3C,43
00A90:  MOVFF  3F,44
00A94:  MOVF   3B,W
00A96:  SUBWF  44,F
00A98:  BZ    0AA6
00A9A:  BTFSS  43.7
00A9C:  BRA    0AEA
00A9E:  MOVF   FD8,W
00AA0:  XORLW  01
00AA2:  MOVWF  FD8
00AA4:  BRA    0AEA
00AA6:  MOVFF  40,44
00AAA:  MOVF   3C,W
00AAC:  SUBWF  44,F
00AAE:  BZ    0ABC
00AB0:  BTFSS  43.7
00AB2:  BRA    0AEA
00AB4:  MOVF   FD8,W
00AB6:  XORLW  01
00AB8:  MOVWF  FD8
00ABA:  BRA    0AEA
00ABC:  MOVFF  41,44
00AC0:  MOVF   3D,W
00AC2:  SUBWF  44,F
00AC4:  BZ    0AD2
00AC6:  BTFSS  43.7
00AC8:  BRA    0AEA
00ACA:  MOVF   FD8,W
00ACC:  XORLW  01
00ACE:  MOVWF  FD8
00AD0:  BRA    0AEA
00AD2:  MOVFF  42,44
00AD6:  MOVF   3E,W
00AD8:  SUBWF  44,F
00ADA:  BZ    0AE8
00ADC:  BTFSS  43.7
00ADE:  BRA    0AEA
00AE0:  MOVF   FD8,W
00AE2:  XORLW  01
00AE4:  MOVWF  FD8
00AE6:  BRA    0AEA
00AE8:  BCF    FD8.0
00AEA:  RETURN 0
00AEC:  MOVF   48,W
00AEE:  SUBLW  B6
00AF0:  MOVWF  48
00AF2:  CLRF   03
00AF4:  MOVFF  49,4C
00AF8:  BSF    49.7
00AFA:  BCF    FD8.0
00AFC:  RRCF   49,F
00AFE:  RRCF   4A,F
00B00:  RRCF   4B,F
00B02:  RRCF   03,F
00B04:  RRCF   02,F
00B06:  RRCF   01,F
00B08:  RRCF   00,F
00B0A:  DECFSZ 48,F
00B0C:  BRA    0AFA
00B0E:  BTFSS  4C.7
00B10:  BRA    0B28
00B12:  COMF   00,F
00B14:  COMF   01,F
00B16:  COMF   02,F
00B18:  COMF   03,F
00B1A:  INCF   00,F
00B1C:  BTFSC  FD8.2
00B1E:  INCF   01,F
00B20:  BTFSC  FD8.2
00B22:  INCF   02,F
00B24:  BTFSC  FD8.2
00B26:  INCF   03,F
00B28:  GOTO   0C0A (RETURN)
00B2C:  BTFSC  FD8.1
00B2E:  BRA    0B36
00B30:  CLRF   FEA
00B32:  MOVLW  50
00B34:  MOVWF  FE9
00B36:  CLRF   00
00B38:  CLRF   01
00B3A:  CLRF   02
00B3C:  CLRF   03
00B3E:  CLRF   50
00B40:  CLRF   51
00B42:  CLRF   52
00B44:  CLRF   53
00B46:  MOVF   4F,W
00B48:  IORWF  4E,W
00B4A:  IORWF  4D,W
00B4C:  IORWF  4C,W
00B4E:  BZ    0BA8
00B50:  MOVLW  20
00B52:  MOVWF  54
00B54:  BCF    FD8.0
00B56:  RLCF   48,F
00B58:  RLCF   49,F
00B5A:  RLCF   4A,F
00B5C:  RLCF   4B,F
00B5E:  RLCF   50,F
00B60:  RLCF   51,F
00B62:  RLCF   52,F
00B64:  RLCF   53,F
00B66:  MOVF   4F,W
00B68:  SUBWF  53,W
00B6A:  BNZ   0B7C
00B6C:  MOVF   4E,W
00B6E:  SUBWF  52,W
00B70:  BNZ   0B7C
00B72:  MOVF   4D,W
00B74:  SUBWF  51,W
00B76:  BNZ   0B7C
00B78:  MOVF   4C,W
00B7A:  SUBWF  50,W
00B7C:  BNC   0B9C
00B7E:  MOVF   4C,W
00B80:  SUBWF  50,F
00B82:  MOVF   4D,W
00B84:  BTFSS  FD8.0
00B86:  INCFSZ 4D,W
00B88:  SUBWF  51,F
00B8A:  MOVF   4E,W
00B8C:  BTFSS  FD8.0
00B8E:  INCFSZ 4E,W
00B90:  SUBWF  52,F
00B92:  MOVF   4F,W
00B94:  BTFSS  FD8.0
00B96:  INCFSZ 4F,W
00B98:  SUBWF  53,F
00B9A:  BSF    FD8.0
00B9C:  RLCF   00,F
00B9E:  RLCF   01,F
00BA0:  RLCF   02,F
00BA2:  RLCF   03,F
00BA4:  DECFSZ 54,F
00BA6:  BRA    0B54
00BA8:  MOVFF  50,FEF
00BAC:  MOVFF  51,FEC
00BB0:  MOVFF  52,FEC
00BB4:  MOVFF  53,FEC
00BB8:  RETURN 0
00BBA:  MOVF   FE9,W
00BBC:  MOVWF  40
00BBE:  MOVF   3F,W
00BC0:  MOVWF  42
00BC2:  BZ    0BF8
00BC4:  MOVFF  3E,4D
00BC8:  MOVFF  3D,4C
00BCC:  MOVFF  3C,4B
00BD0:  MOVFF  3B,4A
00BD4:  CLRF   51
00BD6:  CLRF   50
00BD8:  MOVLW  20
00BDA:  MOVWF  4F
00BDC:  MOVLW  82
00BDE:  MOVWF  4E
00BE0:  CALL   0358
00BE4:  MOVFF  03,3E
00BE8:  MOVFF  02,3D
00BEC:  MOVFF  01,3C
00BF0:  MOVFF  00,3B
00BF4:  DECFSZ 42,F
00BF6:  BRA    0BC4
00BF8:  MOVFF  3E,4B
00BFC:  MOVFF  3D,4A
00C00:  MOVFF  3C,49
00C04:  MOVFF  3B,48
00C08:  BRA    0AEC
00C0A:  MOVFF  03,3E
00C0E:  MOVFF  02,3D
00C12:  MOVFF  01,3C
00C16:  MOVFF  00,3B
00C1A:  BTFSS  3E.7
00C1C:  BRA    0C38
00C1E:  DECF   40,F
00C20:  BSF    40.5
00C22:  COMF   3B,F
00C24:  COMF   3C,F
00C26:  COMF   3D,F
00C28:  COMF   3E,F
00C2A:  INCF   3B,F
00C2C:  BTFSC  FD8.2
00C2E:  INCF   3C,F
00C30:  BTFSC  FD8.2
00C32:  INCF   3D,F
00C34:  BTFSC  FD8.2
00C36:  INCF   3E,F
00C38:  MOVLW  3B
00C3A:  MOVWF  47
00C3C:  MOVLW  9A
00C3E:  MOVWF  46
00C40:  MOVLW  CA
00C42:  MOVWF  45
00C44:  CLRF   44
00C46:  MOVLW  0A
00C48:  MOVWF  42
00C4A:  MOVF   3F,W
00C4C:  BTFSC  FD8.2
00C4E:  INCF   40,F
00C50:  BSF    FD8.1
00C52:  CLRF   FEA
00C54:  MOVLW  3B
00C56:  MOVWF  FE9
00C58:  MOVFF  3E,4B
00C5C:  MOVFF  3D,4A
00C60:  MOVFF  3C,49
00C64:  MOVFF  3B,48
00C68:  MOVFF  47,4F
00C6C:  MOVFF  46,4E
00C70:  MOVFF  45,4D
00C74:  MOVFF  44,4C
00C78:  RCALL  0B2C
00C7A:  MOVF   01,W
00C7C:  MOVF   00,F
00C7E:  BNZ   0C9E
00C80:  INCF   3F,W
00C82:  SUBWF  42,W
00C84:  BZ    0C9E
00C86:  MOVF   40,W
00C88:  BZ    0CA2
00C8A:  ANDLW  0F
00C8C:  SUBWF  42,W
00C8E:  BZ    0C92
00C90:  BC    0D08
00C92:  BTFSC  40.7
00C94:  BRA    0D08
00C96:  BTFSC  40.6
00C98:  BRA    0CA2
00C9A:  MOVLW  20
00C9C:  BRA    0CFE
00C9E:  MOVLW  20
00CA0:  ANDWF  40,F
00CA2:  BTFSS  40.5
00CA4:  BRA    0CC0
00CA6:  BCF    40.5
00CA8:  MOVF   3F,W
00CAA:  BTFSS  FD8.2
00CAC:  DECF   40,F
00CAE:  MOVF   00,W
00CB0:  MOVWF  40
00CB2:  MOVLW  2D
00CB4:  BTFSS  F9E.4
00CB6:  BRA    0CB4
00CB8:  MOVWF  FAD
00CBA:  MOVF   40,W
00CBC:  MOVWF  00
00CBE:  CLRF   40
00CC0:  MOVF   3F,W
00CC2:  SUBWF  42,W
00CC4:  BNZ   0CDC
00CC6:  MOVF   00,W
00CC8:  MOVWF  40
00CCA:  MOVLW  2E
00CCC:  BTFSS  F9E.4
00CCE:  BRA    0CCC
00CD0:  MOVWF  FAD
00CD2:  MOVF   40,W
00CD4:  MOVWF  00
00CD6:  MOVLW  20
00CD8:  ANDWF  40,F
00CDA:  MOVLW  00
00CDC:  MOVLW  30
00CDE:  BTFSS  40.5
00CE0:  BRA    0CFE
00CE2:  BCF    40.5
00CE4:  MOVF   3F,W
00CE6:  BTFSS  FD8.2
00CE8:  DECF   40,F
00CEA:  MOVF   00,W
00CEC:  MOVWF  40
00CEE:  MOVLW  2D
00CF0:  BTFSS  F9E.4
00CF2:  BRA    0CF0
00CF4:  MOVWF  FAD
00CF6:  MOVF   40,W
00CF8:  MOVWF  00
00CFA:  CLRF   40
00CFC:  MOVLW  30
00CFE:  ADDWF  00,F
00D00:  MOVF   00,W
00D02:  BTFSS  F9E.4
00D04:  BRA    0D02
00D06:  MOVWF  FAD
00D08:  BCF    FD8.1
00D0A:  MOVFF  47,4B
00D0E:  MOVFF  46,4A
00D12:  MOVFF  45,49
00D16:  MOVFF  44,48
00D1A:  CLRF   4F
00D1C:  CLRF   4E
00D1E:  CLRF   4D
00D20:  MOVLW  0A
00D22:  MOVWF  4C
00D24:  RCALL  0B2C
00D26:  MOVFF  03,47
00D2A:  MOVFF  02,46
00D2E:  MOVFF  01,45
00D32:  MOVFF  00,44
00D36:  DECFSZ 42,F
00D38:  BRA    0C50
00D3A:  RETURN 0
00D3C:  TBLRD*+
00D3E:  MOVFF  FF6,3C
00D42:  MOVFF  FF7,3D
00D46:  MOVF   FF5,W
00D48:  BTFSS  F9E.4
00D4A:  BRA    0D48
00D4C:  MOVWF  FAD
00D4E:  MOVFF  3C,FF6
00D52:  MOVFF  3D,FF7
00D56:  DECFSZ 3B,F
00D58:  BRA    0D3C
00D5A:  GOTO   1150 (RETURN)
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
00844:  CLRF   42
00846:  CLRF   41
00848:  CLRF   40
0084A:  MOVLW  7F
0084C:  MOVWF  3F
0084E:  CLRF   46
00850:  CLRF   45
00852:  CLRF   44
00854:  CLRF   43
00856:  BSF    47.0
00858:  BCF    47.1
0085A:  BCF    47.2
0085C:  CLRF   49
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0085E:  MOVF   3B,W
00860:  IORWF  3C,W
00862:  BNZ   086E
....................       return 0; 
00864:  CLRF   00
00866:  CLRF   01
00868:  CLRF   02
0086A:  CLRF   03
0086C:  BRA    0A74
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0086E:  MOVF   49,W
00870:  INCF   49,F
00872:  CLRF   03
00874:  ADDWF  3B,W
00876:  MOVWF  FE9
00878:  MOVF   3C,W
0087A:  ADDWFC 03,W
0087C:  MOVWF  FEA
0087E:  MOVFF  FEF,48
00882:  MOVF   48,F
00884:  BTFSC  FD8.2
00886:  BRA    09FE
....................    { 
....................       if (skip && !isspace(c)) 
00888:  BTFSS  47.0
0088A:  BRA    08AA
0088C:  MOVF   48,W
0088E:  SUBLW  20
00890:  BZ    08AA
....................       { 
....................          skip = 0; 
00892:  BCF    47.0
....................          if (c == '+') 
00894:  MOVF   48,W
00896:  SUBLW  2B
00898:  BNZ   08A0
....................          { 
....................             sign = 0; 
0089A:  BCF    47.1
....................             continue; 
0089C:  BRA    09E8
....................          }             
0089E:  BRA    08AA
....................          else if (c == '-') 
008A0:  MOVF   48,W
008A2:  SUBLW  2D
008A4:  BNZ   08AA
....................          { 
....................             sign = 1; 
008A6:  BSF    47.1
....................             continue; 
008A8:  BRA    09E8
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
008AA:  BTFSC  47.0
008AC:  BRA    08BC
008AE:  MOVF   48,W
008B0:  SUBLW  2E
008B2:  BNZ   08BC
008B4:  BTFSC  47.2
008B6:  BRA    08BC
....................          point = 1; 
008B8:  BSF    47.2
008BA:  BRA    09E8
....................       else if (!skip && isdigit(c)) 
008BC:  BTFSC  47.0
008BE:  BRA    09E2
008C0:  MOVF   48,W
008C2:  SUBLW  2F
008C4:  BTFSC  FD8.0
008C6:  BRA    09E2
008C8:  MOVF   48,W
008CA:  SUBLW  39
008CC:  BTFSS  FD8.0
008CE:  BRA    09E2
....................       { 
....................          c -= '0'; 
008D0:  MOVLW  30
008D2:  SUBWF  48,F
....................          if (point) 
008D4:  BTFSS  47.2
008D6:  BRA    0976
....................          { 
....................             pow10 = pow10 * 10.0; 
008D8:  MOVFF  42,4D
008DC:  MOVFF  41,4C
008E0:  MOVFF  40,4B
008E4:  MOVFF  3F,4A
008E8:  CLRF   51
008EA:  CLRF   50
008EC:  MOVLW  20
008EE:  MOVWF  4F
008F0:  MOVLW  82
008F2:  MOVWF  4E
008F4:  RCALL  0358
008F6:  MOVFF  03,42
008FA:  MOVFF  02,41
008FE:  MOVFF  01,40
00902:  MOVFF  00,3F
....................             result += (float)c / pow10;    
00906:  CLRF   4F
00908:  MOVFF  48,4E
0090C:  RCALL  044A
0090E:  MOVFF  03,4D
00912:  MOVFF  02,4C
00916:  MOVFF  01,4B
0091A:  MOVFF  00,4A
0091E:  MOVFF  03,51
00922:  MOVFF  02,50
00926:  MOVFF  01,4F
0092A:  MOVFF  00,4E
0092E:  MOVFF  42,55
00932:  MOVFF  41,54
00936:  MOVFF  40,53
0093A:  MOVFF  3F,52
0093E:  RCALL  0480
00940:  BCF    FD8.1
00942:  MOVFF  46,51
00946:  MOVFF  45,50
0094A:  MOVFF  44,4F
0094E:  MOVFF  43,4E
00952:  MOVFF  03,55
00956:  MOVFF  02,54
0095A:  MOVFF  01,53
0095E:  MOVFF  00,52
00962:  RCALL  05DA
00964:  MOVFF  03,46
00968:  MOVFF  02,45
0096C:  MOVFF  01,44
00970:  MOVFF  00,43
....................          } 
00974:  BRA    09E0
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
00976:  CLRF   4D
00978:  CLRF   4C
0097A:  MOVLW  20
0097C:  MOVWF  4B
0097E:  MOVLW  82
00980:  MOVWF  4A
00982:  MOVFF  46,51
00986:  MOVFF  45,50
0098A:  MOVFF  44,4F
0098E:  MOVFF  43,4E
00992:  RCALL  0358
00994:  MOVFF  03,4D
00998:  MOVFF  02,4C
0099C:  MOVFF  01,4B
009A0:  MOVFF  00,4A
009A4:  CLRF   4F
009A6:  MOVFF  48,4E
009AA:  RCALL  044A
009AC:  BCF    FD8.1
009AE:  MOVFF  4D,51
009B2:  MOVFF  4C,50
009B6:  MOVFF  4B,4F
009BA:  MOVFF  4A,4E
009BE:  MOVFF  03,55
009C2:  MOVFF  02,54
009C6:  MOVFF  01,53
009CA:  MOVFF  00,52
009CE:  RCALL  05DA
009D0:  MOVFF  03,46
009D4:  MOVFF  02,45
009D8:  MOVFF  01,44
009DC:  MOVFF  00,43
....................          } 
....................       } 
009E0:  BRA    09E8
....................       else if (!skip) 
009E2:  BTFSC  47.0
009E4:  BRA    09E8
....................          break; 
009E6:  BRA    09FE
009E8:  MOVF   49,W
009EA:  INCF   49,F
009EC:  CLRF   03
009EE:  ADDWF  3B,W
009F0:  MOVWF  FE9
009F2:  MOVF   3C,W
009F4:  ADDWFC 03,W
009F6:  MOVWF  FEA
009F8:  MOVFF  FEF,48
009FC:  BRA    0882
....................    } 
....................  
....................    if (sign) 
009FE:  BTFSS  47.1
00A00:  BRA    0A30
....................       result = -1*result; 
00A02:  CLRF   4D
00A04:  CLRF   4C
00A06:  MOVLW  80
00A08:  MOVWF  4B
00A0A:  MOVLW  7F
00A0C:  MOVWF  4A
00A0E:  MOVFF  46,51
00A12:  MOVFF  45,50
00A16:  MOVFF  44,4F
00A1A:  MOVFF  43,4E
00A1E:  RCALL  0358
00A20:  MOVFF  03,46
00A24:  MOVFF  02,45
00A28:  MOVFF  01,44
00A2C:  MOVFF  00,43
....................        
....................    if(endptr) 
00A30:  MOVF   3D,W
00A32:  IORWF  3E,W
00A34:  BZ    0A64
....................    { 
....................       if (ptr) { 
00A36:  MOVF   49,F
00A38:  BZ    0A52
....................          ptr--; 
00A3A:  DECF   49,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
00A3C:  MOVFF  3D,FE9
00A40:  MOVFF  3E,FEA
00A44:  MOVF   49,W
00A46:  ADDWF  3B,W
00A48:  MOVWF  FEF
00A4A:  MOVLW  00
00A4C:  ADDWFC 3C,W
00A4E:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
00A50:  BRA    0A64
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
00A52:  MOVFF  3D,FE9
00A56:  MOVFF  3E,FEA
00A5A:  MOVFF  3C,FEC
00A5E:  MOVF   FED,F
00A60:  MOVFF  3B,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
00A64:  MOVFF  43,00
00A68:  MOVFF  44,01
00A6C:  MOVFF  45,02
00A70:  MOVFF  46,03
00A74:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <float.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* float.h  */ 
....................  
....................  
.................... #ifndef _FLOAT 
.................... #define _FLOAT 
....................     /* Float properties */ 
....................  
.................... #define FLT_RADIX       2 
.................... #define FLT_MANT_DIG    24                              // # of bits in mantissa 
....................  
.................... #define FLT_DIG         6                               // # of decimal digits of precision 
....................  
.................... #define FLT_MIN_EXP     (-125)                          // min binary exponent 
.................... #define FLT_MIN_10_EXP  (-37)                           // min decimal exponent 
.................... #define FLT_MAX_EXP     128                             // max binary exponent 
.................... #define FLT_MAX_10_EXP  38                              // max decimal exponent 
.................... #define FLT_MAX         3.402823466e+38F                // max value 
.................... #define FLT_EPSILON     1.192092896e-07F                // smallest such that 1.0+FLT_EPSILON != 1.0 
.................... #define FLT_MIN         1.175494351e-38F                // min positive value 
....................  
....................  
....................       /* Double properties */ 
.................... #define DBL_MANT_DIG    53                              // # of bits in mantissa 
....................  
.................... #define DBL_DIG         15                              // # of decimal digits of precision 
....................  
.................... #define DBL_MIN_EXP     (-1021)                         // min binary exponent 
.................... #define DBL_MIN_10_EXP  (-307)                          // min decimal exponent 
.................... #define DBL_MAX_EXP     1024                            // max binary exponent 
.................... #define DBL_MAX_10_EXP  308                             // max decimal exponent 
.................... #define DBL_MAX         1.79769313486231e+308F          // max value 
.................... #define DBL_EPSILON     2.2204460492503131e-16F         // smallest such that 1.0+FLT_EPSILON != 1.0 
.................... #define DBL_MIN         2.22507385850721e-308F          // min positive value 
....................  
....................          /*Long double properties */ 
....................           
.................... #define LDBL_MANT_DIG    64                             // # of bits in mantissa 
....................  
.................... #define LDBL_DIG         18                             // # of decimal digits of precision 
....................  
.................... #define LDBL_MIN_EXP     (-16381)                       // min binary exponent 
.................... #define LDBL_MIN_10_EXP  (-4931)                        // min decimal exponent 
.................... #define LDBL_MAX_EXP     16384                          // max binary exponent 
.................... #define LDBL_MAX_10_EXP  4932                           // max decimal exponent 
.................... #define LDBL_MAX         1.18973149535723176502e+4932F  // max value 
.................... #define LDBL_EPSILON     1.084202172485504434e-019F     // smallest such that 1.0+FLT_EPSILON != 1.0 
.................... #define LDBL_MIN         3.36210314311209350626e-4932F  // min positive value 
.................... #endif 
....................  
....................  
....................  
.................... #fuses XT, NOFCMEN, NOIESO, PUT, NOBROWNOUT, NOWDT  
.................... #fuses NOPBADEN, NOMCLR, STVREN, NOLVP, NODEBUG 
.................... #use delay(clock=16000000) 
.................... #use RS232(BAUD=9600,BITS=8,PARITY=N,XMIT=PIN_C6,RCV=PIN_C7,STOP=1)   
.................... #use standard_io(c) 
.................... #define tamanoBufer 11 
.................... //Variables globales 
.................... char Bufer[11]; 
.................... int datoMalo=0; 
.................... int posicion=0; 
.................... int terminadoRDA=0; 
.................... int timeOut=0; 
.................... unsigned int16 contador15s=0; 
.................... int8 punto=0; 
.................... #int_rda 
.................... void rda_isr() 
.................... {      
....................       Bufer[posicion]=getc();                     //Guarda lo tecleado en el Bufer en la posicion actual 
*
000A2:  CLRF   03
000A4:  MOVF   28,W
000A6:  ADDLW  1C
000A8:  MOVWF  FE9
000AA:  MOVLW  00
000AC:  ADDWFC 03,W
000AE:  MOVWF  FEA
000B0:  BTFSS  F9E.5
000B2:  BRA    00B0
000B4:  MOVFF  FAE,FEF
....................       disable_interrupts(int_TIMER0);            //Desactiva la interrupcin de TMR0 
000B8:  BCF    FF2.5
....................       contador15s=0; 
000BA:  CLRF   2C
000BC:  CLRF   2B
....................       if(Bufer[posicion]==0x0A || Bufer[posicion]==0x0D)     //Si recivio enter 
000BE:  CLRF   03
000C0:  MOVF   28,W
000C2:  ADDLW  1C
000C4:  MOVWF  FE9
000C6:  MOVLW  00
000C8:  ADDWFC 03,W
000CA:  MOVWF  FEA
000CC:  MOVF   FEF,W
000CE:  SUBLW  0A
000D0:  BZ    00E6
000D2:  CLRF   03
000D4:  MOVF   28,W
000D6:  ADDLW  1C
000D8:  MOVWF  FE9
000DA:  MOVLW  00
000DC:  ADDWFC 03,W
000DE:  MOVWF  FEA
000E0:  MOVF   FEF,W
000E2:  SUBLW  0D
000E4:  BNZ   00EA
....................       { 
....................          terminadoRDA=1; 
000E6:  MOVLW  01
000E8:  MOVWF  29
....................       } 
....................       if(!(posicion<tamanoBufer-1))                         //Si no es menor de 9 (la ultima posicin del vector para escribir), activa bandera para que termine la interrupcin 
000EA:  MOVF   28,W
000EC:  SUBLW  09
000EE:  BC    00F4
....................       { 
....................          terminadoRDA=1; 
000F0:  MOVLW  01
000F2:  MOVWF  29
....................       } 
....................       if(((Bufer[posicion]<'0' || Bufer[posicion]>'9') && (Bufer[posicion]!='-') && (Bufer[posicion]!='.') && (Bufer[posicion]!=0x0A && Bufer[posicion]!=0x0D)) || (posicion>0 && Bufer[posicion]=='-') || (punto>1))     //Si no ingreso un numero, un - o un .   El dato no es valido 
000F4:  CLRF   03
000F6:  MOVF   28,W
000F8:  ADDLW  1C
000FA:  MOVWF  FE9
000FC:  MOVLW  00
000FE:  ADDWFC 03,W
00100:  MOVWF  FEA
00102:  MOVF   FEF,W
00104:  SUBLW  2F
00106:  BC    011C
00108:  CLRF   03
0010A:  MOVF   28,W
0010C:  ADDLW  1C
0010E:  MOVWF  FE9
00110:  MOVLW  00
00112:  ADDWFC 03,W
00114:  MOVWF  FEA
00116:  MOVF   FEF,W
00118:  SUBLW  39
0011A:  BC    016C
0011C:  CLRF   03
0011E:  MOVF   28,W
00120:  ADDLW  1C
00122:  MOVWF  FE9
00124:  MOVLW  00
00126:  ADDWFC 03,W
00128:  MOVWF  FEA
0012A:  MOVF   FEF,W
0012C:  SUBLW  2D
0012E:  BZ    016C
00130:  CLRF   03
00132:  MOVF   28,W
00134:  ADDLW  1C
00136:  MOVWF  FE9
00138:  MOVLW  00
0013A:  ADDWFC 03,W
0013C:  MOVWF  FEA
0013E:  MOVF   FEF,W
00140:  SUBLW  2E
00142:  BZ    016C
00144:  CLRF   03
00146:  MOVF   28,W
00148:  ADDLW  1C
0014A:  MOVWF  FE9
0014C:  MOVLW  00
0014E:  ADDWFC 03,W
00150:  MOVWF  FEA
00152:  MOVF   FEF,W
00154:  SUBLW  0A
00156:  BZ    016C
00158:  CLRF   03
0015A:  MOVF   28,W
0015C:  ADDLW  1C
0015E:  MOVWF  FE9
00160:  MOVLW  00
00162:  ADDWFC 03,W
00164:  MOVWF  FEA
00166:  MOVF   FEF,W
00168:  SUBLW  0D
0016A:  BNZ   018A
0016C:  MOVF   28,F
0016E:  BZ    0184
00170:  CLRF   03
00172:  MOVF   28,W
00174:  ADDLW  1C
00176:  MOVWF  FE9
00178:  MOVLW  00
0017A:  ADDWFC 03,W
0017C:  MOVWF  FEA
0017E:  MOVF   FEF,W
00180:  SUBLW  2D
00182:  BZ    018A
00184:  MOVF   2D,W
00186:  SUBLW  01
00188:  BC    018E
....................       { 
....................          datoMalo=1; 
0018A:  MOVLW  01
0018C:  MOVWF  27
....................       } 
....................       if(Bufer[posicion]=='.') 
0018E:  CLRF   03
00190:  MOVF   28,W
00192:  ADDLW  1C
00194:  MOVWF  FE9
00196:  MOVLW  00
00198:  ADDWFC 03,W
0019A:  MOVWF  FEA
0019C:  MOVF   FEF,W
0019E:  SUBLW  2E
001A0:  BNZ   01A4
....................       { 
....................          punto++; 
001A2:  INCF   2D,F
....................       } 
....................       posicion++; 
001A4:  INCF   28,F
....................       enable_interrupts(int_TIMER0);                  //Habilita la interrupcion de TMR0 
001A6:  BSF    FF2.5
....................  
.................... } 
001A8:  BCF    F9E.5
001AA:  GOTO   0060
.................... #int_timer0 
.................... void contador_TMR0() 
.................... { 
....................    if(contador15s>=916) 
001AE:  MOVF   2C,W
001B0:  SUBLW  02
001B2:  BC    01C6
001B4:  XORLW  FF
001B6:  BNZ   01BE
001B8:  MOVF   2B,W
001BA:  SUBLW  93
001BC:  BC    01C6
....................    { 
....................       terminadoRDA=1; 
001BE:  MOVLW  01
001C0:  MOVWF  29
....................       datoMalo=1; 
001C2:  MOVWF  27
....................       timeOut=1; 
001C4:  MOVWF  2A
....................    } 
....................    contador15s++; 
001C6:  INCF   2B,F
001C8:  BTFSC  FD8.2
001CA:  INCF   2C,F
001CC:  BCF    FF2.2
001CE:  GOTO   0060
.................... } 
.................... void limpiarBufer(); 
.................... void main(void) 
*
00D5E:  CLRF   FF8
00D60:  BCF    FD0.7
00D62:  BSF    07.7
00D64:  BSF    FB8.3
00D66:  MOVLW  A0
00D68:  MOVWF  FAF
00D6A:  MOVLW  01
00D6C:  MOVWF  FB0
00D6E:  MOVLW  A6
00D70:  MOVWF  FAC
00D72:  MOVLW  90
00D74:  MOVWF  FAB
00D76:  CLRF   27
00D78:  CLRF   28
00D7A:  CLRF   29
00D7C:  CLRF   2A
00D7E:  CLRF   2C
00D80:  CLRF   2B
00D82:  CLRF   2D
00D84:  MOVF   FC1,W
00D86:  ANDLW  C0
00D88:  IORLW  0F
00D8A:  MOVWF  FC1
00D8C:  MOVLW  07
00D8E:  MOVWF  FB4
00D90:  CLRF   16
00D92:  CLRF   17
.................... { 
....................    //Configuraciones del microcontrolador 
....................    setup_oscillator(OSC_16MHZ); 
00D94:  MOVLW  60
00D96:  MOVWF  FD3
00D98:  MOVLW  40
00D9A:  MOVWF  F9B
00D9C:  MOVF   FD3,W
....................    enable_interrupts(global); 
00D9E:  MOVLW  C0
00DA0:  IORWF  FF2,F
....................    enable_interrupts(int_rda); 
00DA2:  BSF    F9D.5
....................    SETUP_ADC_PORTS(NO_ANALOGS); 
00DA4:  MOVF   FC1,W
00DA6:  ANDLW  C0
00DA8:  IORLW  0F
00DAA:  MOVWF  FC1
....................    set_timer0(256); 
00DAC:  MOVLW  01
00DAE:  MOVWF  FD7
00DB0:  CLRF   FD6
....................    setup_timer_0(RTCC_internal|RTCC_DIV_256|RTCC_8_BIT); 
00DB2:  MOVLW  C7
00DB4:  MOVWF  FD5
....................    //Variables 
....................    inicio:   //Punto de retorno 
....................    float32 primerOperando=0, segundoOperando=0, resultado=0; 
....................    char operacion='0'; 
00DB6:  CLRF   31
00DB8:  CLRF   30
00DBA:  CLRF   2F
00DBC:  CLRF   2E
00DBE:  CLRF   35
00DC0:  CLRF   34
00DC2:  CLRF   33
00DC4:  CLRF   32
00DC6:  CLRF   39
00DC8:  CLRF   38
00DCA:  CLRF   37
00DCC:  CLRF   36
00DCE:  MOVLW  30
00DD0:  MOVWF  3A
....................    contador15s=0; 
00DD2:  CLRF   2C
00DD4:  CLRF   2B
....................    //// 
....................    while(true) 
....................    {    
....................       //Inicializamos variables a 0 y limpiamos Bufer 
....................       posicion=0; 
00DD6:  CLRF   28
....................       datoMalo=0; 
00DD8:  CLRF   27
....................       terminadoRDA=0; 
00DDA:  CLRF   29
....................       timeOut=0; 
00DDC:  CLRF   2A
....................       punto=0; 
00DDE:  CLRF   2D
....................       limpiarBufer(); 
00DE0:  CALL   0316
....................        
....................       printf("Practica No. 4\r"); 
00DE4:  MOVLW  D2
00DE6:  MOVWF  FF6
00DE8:  MOVLW  01
00DEA:  MOVWF  FF7
00DEC:  CALL   0336
....................       printf("Calculadora Aritmetica \r\r"); 
00DF0:  MOVLW  E2
00DF2:  MOVWF  FF6
00DF4:  MOVLW  01
00DF6:  MOVWF  FF7
00DF8:  CALL   0336
....................                                                   //primerOperando 
....................       printf("Ingresa el primer operando \r");    //Indica al usuario que ingrese el primer operando     
00DFC:  MOVLW  FC
00DFE:  MOVWF  FF6
00E00:  MOVLW  01
00E02:  MOVWF  FF7
00E04:  CALL   0336
....................       While(terminadoRDA==0);                   //Mientras no aya terminado de recivir la trama se queda ciclado 
00E08:  MOVF   29,F
00E0A:  BZ    0E08
....................       disable_interrupts(int_TIMER0);            //Desactiva la interrupcin de TMR0 
00E0C:  BCF    FF2.5
....................       contador15s=0;                            //Reinicia el contador15s 
00E0E:  CLRF   2C
00E10:  CLRF   2B
....................       if(datoMalo==1)                            //Si el dato ingresado no es correcto 
00E12:  DECFSZ 27,W
00E14:  BRA    0E34
....................       { 
....................          error: 
....................          printf("Error \r\r"); 
00E16:  MOVLW  1A
00E18:  MOVWF  FF6
00E1A:  MOVLW  02
00E1C:  MOVWF  FF7
00E1E:  CALL   0336
....................          if(timeOut==1) 
00E22:  DECFSZ 2A,W
00E24:  BRA    0E32
....................          { 
....................             printf("Se ha terminado el tiempo \r\r"); 
00E26:  MOVLW  24
00E28:  MOVWF  FF6
00E2A:  MOVLW  02
00E2C:  MOVWF  FF7
00E2E:  CALL   0336
....................          } 
....................          goto inicio; 
00E32:  BRA    0DB6
....................       } 
....................        if(Bufer[posicion-1]==0x0A || Bufer[posicion-1]==0x0D)     //Si la ultima tecla presionada fue enter, la hace igual a NULL 
00E34:  MOVLW  01
00E36:  SUBWF  28,W
00E38:  CLRF   03
00E3A:  ADDLW  1C
00E3C:  MOVWF  FE9
00E3E:  MOVLW  00
00E40:  ADDWFC 03,W
00E42:  MOVWF  FEA
00E44:  MOVF   FEF,W
00E46:  SUBLW  0A
00E48:  BZ    0E60
00E4A:  MOVLW  01
00E4C:  SUBWF  28,W
00E4E:  CLRF   03
00E50:  ADDLW  1C
00E52:  MOVWF  FE9
00E54:  MOVLW  00
00E56:  ADDWFC 03,W
00E58:  MOVWF  FEA
00E5A:  MOVF   FEF,W
00E5C:  SUBLW  0D
00E5E:  BNZ   0E72
....................       { 
....................          Bufer[posicion-1]=0; 
00E60:  MOVLW  01
00E62:  SUBWF  28,W
00E64:  CLRF   03
00E66:  ADDLW  1C
00E68:  MOVWF  FE9
00E6A:  MOVLW  00
00E6C:  ADDWFC 03,W
00E6E:  MOVWF  FEA
00E70:  CLRF   FEF
....................       } 
....................       primerOperando=atof(Bufer);                 //Asigna la cifra casteandola a un flotante, a primer operando en "primerOperando 
00E72:  CLRF   3C
00E74:  MOVLW  1C
00E76:  MOVWF  3B
00E78:  CLRF   3E
00E7A:  CLRF   3D
00E7C:  RCALL  0844
00E7E:  MOVFF  03,31
00E82:  MOVFF  02,30
00E86:  MOVFF  01,2F
00E8A:  MOVFF  00,2E
....................       if(primerOperando>9999.9999)                //Si el operando supera el valor maximo, lo manda a donde imprime Error 
00E8E:  CLRF   3E
00E90:  MOVLW  40
00E92:  MOVWF  3D
00E94:  MOVLW  1C
00E96:  MOVWF  3C
00E98:  MOVLW  8C
00E9A:  MOVWF  3B
00E9C:  MOVFF  31,42
00EA0:  MOVFF  30,41
00EA4:  MOVFF  2F,40
00EA8:  MOVFF  2E,3F
00EAC:  RCALL  0A76
00EAE:  BNC   0EB2
....................       { 
....................          goto error; 
00EB0:  BRA    0E16
....................       } 
....................       printf("%4.4f\r",primerOperando);              //Muestra el operando ingresado 
00EB2:  MOVLW  89
00EB4:  MOVWF  FE9
00EB6:  MOVFF  31,3E
00EBA:  MOVFF  30,3D
00EBE:  MOVFF  2F,3C
00EC2:  MOVFF  2E,3B
00EC6:  MOVLW  04
00EC8:  MOVWF  3F
00ECA:  RCALL  0BBA
00ECC:  MOVLW  0D
00ECE:  BTFSS  F9E.4
00ED0:  BRA    0ECE
00ED2:  MOVWF  FAD
....................       posicion=0; 
00ED4:  CLRF   28
....................       datoMalo=0; 
00ED6:  CLRF   27
....................       terminadoRDA=0; 
00ED8:  CLRF   29
....................       timeOut=0; 
00EDA:  CLRF   2A
....................       punto=0; 
00EDC:  CLRF   2D
....................       limpiarBufer(); 
00EDE:  CALL   0316
....................                                                     //segundoOperando 
....................       printf("Ingresa el segundo operando \r");          //Indica al usuario que ingrese el segundo operando 
00EE2:  MOVLW  42
00EE4:  MOVWF  FF6
00EE6:  MOVLW  02
00EE8:  MOVWF  FF7
00EEA:  CALL   0336
....................       While(terminadoRDA==0);                   //Mientras no aya terminado de recivir la trama se queda ciclado 
00EEE:  MOVF   29,F
00EF0:  BZ    0EEE
....................       disable_interrupts(int_TIMER0);            //Desactiva la interrupcin de TMR0 
00EF2:  BCF    FF2.5
....................       contador15s=0;                            //Reinicia el contador15s 
00EF4:  CLRF   2C
00EF6:  CLRF   2B
....................       if(datoMalo==1)                            //Si el dato ingresado no es correcto 
00EF8:  DECFSZ 27,W
00EFA:  BRA    0F1A
....................       { 
....................          printf("Error \r"); 
00EFC:  MOVLW  60
00EFE:  MOVWF  FF6
00F00:  MOVLW  02
00F02:  MOVWF  FF7
00F04:  CALL   0336
....................          if(timeOut==1) 
00F08:  DECFSZ 2A,W
00F0A:  BRA    0F18
....................          { 
....................             printf("Se ha terminado el tiempo"); 
00F0C:  MOVLW  68
00F0E:  MOVWF  FF6
00F10:  MOVLW  02
00F12:  MOVWF  FF7
00F14:  CALL   0336
....................          } 
....................          goto inicio; 
00F18:  BRA    0DB6
....................       } 
....................       if(Bufer[posicion-1]==0x0A || Bufer[posicion-1]==0x0D)     //Si la ultima tecla presionada fue enter, la hace igual a NULL 
00F1A:  MOVLW  01
00F1C:  SUBWF  28,W
00F1E:  CLRF   03
00F20:  ADDLW  1C
00F22:  MOVWF  FE9
00F24:  MOVLW  00
00F26:  ADDWFC 03,W
00F28:  MOVWF  FEA
00F2A:  MOVF   FEF,W
00F2C:  SUBLW  0A
00F2E:  BZ    0F46
00F30:  MOVLW  01
00F32:  SUBWF  28,W
00F34:  CLRF   03
00F36:  ADDLW  1C
00F38:  MOVWF  FE9
00F3A:  MOVLW  00
00F3C:  ADDWFC 03,W
00F3E:  MOVWF  FEA
00F40:  MOVF   FEF,W
00F42:  SUBLW  0D
00F44:  BNZ   0F58
....................       { 
....................          Bufer[posicion-1]=0; 
00F46:  MOVLW  01
00F48:  SUBWF  28,W
00F4A:  CLRF   03
00F4C:  ADDLW  1C
00F4E:  MOVWF  FE9
00F50:  MOVLW  00
00F52:  ADDWFC 03,W
00F54:  MOVWF  FEA
00F56:  CLRF   FEF
....................       } 
....................       segundoOperando=atof(Bufer);                    //Asigna la cifra casteandola a un flotante, a segundo operando en "segundoOperando" 
00F58:  CLRF   3C
00F5A:  MOVLW  1C
00F5C:  MOVWF  3B
00F5E:  CLRF   3E
00F60:  CLRF   3D
00F62:  RCALL  0844
00F64:  MOVFF  03,35
00F68:  MOVFF  02,34
00F6C:  MOVFF  01,33
00F70:  MOVFF  00,32
....................       if(segundoOperando>9999.9999)                //Si el operando supera el valor maximo, lo manda a donde imprime Error 
00F74:  CLRF   3E
00F76:  MOVLW  40
00F78:  MOVWF  3D
00F7A:  MOVLW  1C
00F7C:  MOVWF  3C
00F7E:  MOVLW  8C
00F80:  MOVWF  3B
00F82:  MOVFF  35,42
00F86:  MOVFF  34,41
00F8A:  MOVFF  33,40
00F8E:  MOVFF  32,3F
00F92:  RCALL  0A76
00F94:  BNC   0F98
....................       { 
....................          goto error; 
00F96:  BRA    0E16
....................       } 
....................       printf("%4.4f\r",segundoOperando);              //Muestra el operando ingresado 
00F98:  MOVLW  89
00F9A:  MOVWF  FE9
00F9C:  MOVFF  35,3E
00FA0:  MOVFF  34,3D
00FA4:  MOVFF  33,3C
00FA8:  MOVFF  32,3B
00FAC:  MOVLW  04
00FAE:  MOVWF  3F
00FB0:  RCALL  0BBA
00FB2:  MOVLW  0D
00FB4:  BTFSS  F9E.4
00FB6:  BRA    0FB4
00FB8:  MOVWF  FAD
....................       posicion=0; 
00FBA:  CLRF   28
....................       datoMalo=0; 
00FBC:  CLRF   27
....................       terminadoRDA=0; 
00FBE:  CLRF   29
....................       timeOut=0; 
00FC0:  CLRF   2A
....................       punto=0; 
00FC2:  CLRF   2D
....................       limpiarBufer(); 
00FC4:  CALL   0316
....................        
....................                                                                  //Operacion 
....................       printf("Seleccione una operacion: \r 1)Suma  2)Resta  3)Multiplicacion  4)Division \r");    //Indica al usuario que selecione segun su nmero, una operacin  
00FC8:  MOVLW  82
00FCA:  MOVWF  FF6
00FCC:  MOVLW  02
00FCE:  MOVWF  FF7
00FD0:  CALL   0336
....................       While(terminadoRDA==0);                   //Mientras no aya terminado de recivir la trama se queda ciclado 
00FD4:  MOVF   29,F
00FD6:  BZ    0FD4
....................       disable_interrupts(int_TIMER0);            //Desactiva la interrupcin de TMR0 
00FD8:  BCF    FF2.5
....................       contador15s=0;                            //Reinicia el contador15s 
00FDA:  CLRF   2C
00FDC:  CLRF   2B
....................       if(datoMalo==1)                            //Si el dato ingresado no es correcto 
00FDE:  DECFSZ 27,W
00FE0:  BRA    1000
....................       { 
....................          printf("Error \r"); 
00FE2:  MOVLW  CE
00FE4:  MOVWF  FF6
00FE6:  MOVLW  02
00FE8:  MOVWF  FF7
00FEA:  CALL   0336
....................          if(timeOut==1) 
00FEE:  DECFSZ 2A,W
00FF0:  BRA    0FFE
....................          { 
....................             printf("Se ha terminado el tiempo"); 
00FF2:  MOVLW  D6
00FF4:  MOVWF  FF6
00FF6:  MOVLW  02
00FF8:  MOVWF  FF7
00FFA:  CALL   0336
....................          } 
....................          goto inicio; 
00FFE:  BRA    0DB6
....................       } 
....................        if(Bufer[posicion-1]==0x0A || Bufer[posicion-1]==0x0D)     //Si la ultima tecla presionada fue enter, la hace igual a NULL 
01000:  MOVLW  01
01002:  SUBWF  28,W
01004:  CLRF   03
01006:  ADDLW  1C
01008:  MOVWF  FE9
0100A:  MOVLW  00
0100C:  ADDWFC 03,W
0100E:  MOVWF  FEA
01010:  MOVF   FEF,W
01012:  SUBLW  0A
01014:  BZ    102C
01016:  MOVLW  01
01018:  SUBWF  28,W
0101A:  CLRF   03
0101C:  ADDLW  1C
0101E:  MOVWF  FE9
01020:  MOVLW  00
01022:  ADDWFC 03,W
01024:  MOVWF  FEA
01026:  MOVF   FEF,W
01028:  SUBLW  0D
0102A:  BNZ   103E
....................       { 
....................          Bufer[posicion-1]=0; 
0102C:  MOVLW  01
0102E:  SUBWF  28,W
01030:  CLRF   03
01032:  ADDLW  1C
01034:  MOVWF  FE9
01036:  MOVLW  00
01038:  ADDWFC 03,W
0103A:  MOVWF  FEA
0103C:  CLRF   FEF
....................       } 
....................       operacion=Bufer[0];                      //Asigna la operacin casteandola a un flotante, a operacion 
0103E:  MOVFF  1C,3A
....................       posicion=0; 
01042:  CLRF   28
....................       datoMalo=0; 
01044:  CLRF   27
....................       terminadoRDA=0; 
01046:  CLRF   29
....................       timeOut=0; 
01048:  CLRF   2A
....................       punto=0; 
0104A:  CLRF   2D
....................       limpiarBufer(); 
0104C:  CALL   0316
....................    
....................       //Saca resultado con los dos operadores ingresados y deacuerdo a la operacin seleccionada 
....................       if(operacion=='1')   resultado=primerOperando+segundoOperando;          //suma 
01050:  MOVF   3A,W
01052:  SUBLW  31
01054:  BNZ   108E
01056:  BCF    FD8.1
01058:  MOVFF  31,51
0105C:  MOVFF  30,50
01060:  MOVFF  2F,4F
01064:  MOVFF  2E,4E
01068:  MOVFF  35,55
0106C:  MOVFF  34,54
01070:  MOVFF  33,53
01074:  MOVFF  32,52
01078:  CALL   05DA
0107C:  MOVFF  03,39
01080:  MOVFF  02,38
01084:  MOVFF  01,37
01088:  MOVFF  00,36
0108C:  BRA    1142
....................       else if(operacion=='2')   resultado=primerOperando-segundoOperando;     //resta 
0108E:  MOVF   3A,W
01090:  SUBLW  32
01092:  BNZ   10CC
01094:  BSF    FD8.1
01096:  MOVFF  31,51
0109A:  MOVFF  30,50
0109E:  MOVFF  2F,4F
010A2:  MOVFF  2E,4E
010A6:  MOVFF  35,55
010AA:  MOVFF  34,54
010AE:  MOVFF  33,53
010B2:  MOVFF  32,52
010B6:  CALL   05DA
010BA:  MOVFF  03,39
010BE:  MOVFF  02,38
010C2:  MOVFF  01,37
010C6:  MOVFF  00,36
010CA:  BRA    1142
....................       else if(operacion=='3')   resultado=primerOperando*segundoOperando;     //multiplicacion 
010CC:  MOVF   3A,W
010CE:  SUBLW  33
010D0:  BNZ   1108
010D2:  MOVFF  31,4D
010D6:  MOVFF  30,4C
010DA:  MOVFF  2F,4B
010DE:  MOVFF  2E,4A
010E2:  MOVFF  35,51
010E6:  MOVFF  34,50
010EA:  MOVFF  33,4F
010EE:  MOVFF  32,4E
010F2:  CALL   0358
010F6:  MOVFF  03,39
010FA:  MOVFF  02,38
010FE:  MOVFF  01,37
01102:  MOVFF  00,36
01106:  BRA    1142
....................       else if(operacion=='4')   resultado=primerOperando/segundoOperando;     //divicion 
01108:  MOVF   3A,W
0110A:  SUBLW  34
0110C:  BNZ   1142
0110E:  MOVFF  31,51
01112:  MOVFF  30,50
01116:  MOVFF  2F,4F
0111A:  MOVFF  2E,4E
0111E:  MOVFF  35,55
01122:  MOVFF  34,54
01126:  MOVFF  33,53
0112A:  MOVFF  32,52
0112E:  CALL   0480
01132:  MOVFF  03,39
01136:  MOVFF  02,38
0113A:  MOVFF  01,37
0113E:  MOVFF  00,36
....................       //Muestra resultado 
....................       printf("El resultado de la operacion es: %f\r\r",resultado); 
01142:  MOVLW  F0
01144:  MOVWF  FF6
01146:  MOVLW  02
01148:  MOVWF  FF7
0114A:  MOVLW  21
0114C:  MOVWF  3B
0114E:  BRA    0D3C
01150:  MOVLW  89
01152:  MOVWF  FE9
01154:  MOVFF  39,3E
01158:  MOVFF  38,3D
0115C:  MOVFF  37,3C
01160:  MOVFF  36,3B
01164:  MOVLW  02
01166:  MOVWF  3F
01168:  RCALL  0BBA
0116A:  MOVLW  0D
0116C:  BTFSS  F9E.4
0116E:  BRA    116C
01170:  MOVWF  FAD
01172:  MOVLW  0D
01174:  BTFSS  F9E.4
01176:  BRA    1174
01178:  MOVWF  FAD
0117A:  BRA    0DD6
....................    }  
.................... } 
.................... void limpiarBufer() 
*
00316:  CLRF   3B
*
0117C:  SLEEP 
.................... { 
....................    int i=0; 
....................    for(i=0; i<tamanoBufer; i++) 
*
00318:  CLRF   3B
0031A:  MOVF   3B,W
0031C:  SUBLW  0A
0031E:  BNC   0334
....................    { 
....................       Bufer[i]=0; 
00320:  CLRF   03
00322:  MOVF   3B,W
00324:  ADDLW  1C
00326:  MOVWF  FE9
00328:  MOVLW  00
0032A:  ADDWFC 03,W
0032C:  MOVWF  FEA
0032E:  CLRF   FEF
00330:  INCF   3B,F
00332:  BRA    031A
....................    } 
00334:  RETURN 0
.................... } 

Configuration Fuses:
   Word  1: 0100   XT NOFCMEN NOIESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 0500   CCP2C1 NOPBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
