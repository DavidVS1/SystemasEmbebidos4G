CCS PCH C Compiler, Version 5.012, 41559               26-abr.-17 15:32

               Filename:   C:\Users\luis\Documents\4Semestre\Embebidos\SystemasEmbebidos4G\Practica4\programaPrincipal.lst

               ROM used:   3848 bytes (6%)
                           Largest free fragment is 61684
               RAM used:   43 (1%) at main() level
                           91 (2%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   0BD8
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  F9D.5
0004A:  GOTO   0054
0004E:  BTFSC  F9E.5
00050:  GOTO   0096
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... #include <18F4620.h> 
.................... ///////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
*
0010A:  DATA 50,72
0010C:  DATA 61,63
0010E:  DATA 74,69
00110:  DATA 63,61
00112:  DATA 20,4E
00114:  DATA 6F,2E
00116:  DATA 20,34
00118:  DATA 0D,00
0011A:  DATA 43,61
0011C:  DATA 6C,63
0011E:  DATA 75,6C
00120:  DATA 61,64
00122:  DATA 6F,72
00124:  DATA 61,20
00126:  DATA 41,72
00128:  DATA 69,74
0012A:  DATA 6D,65
0012C:  DATA 74,69
0012E:  DATA 63,61
00130:  DATA 20,0D
00132:  DATA 0D,00
00134:  DATA 49,6E
00136:  DATA 67,72
00138:  DATA 65,73
0013A:  DATA 61,20
0013C:  DATA 65,6C
0013E:  DATA 20,70
00140:  DATA 72,69
00142:  DATA 6D,65
00144:  DATA 72,20
00146:  DATA 6F,70
00148:  DATA 65,72
0014A:  DATA 61,6E
0014C:  DATA 64,6F
0014E:  DATA 20,0D
00150:  DATA 00,00
00152:  DATA 44,61
00154:  DATA 74,6F
00156:  DATA 20,69
00158:  DATA 6E,63
0015A:  DATA 6F,72
0015C:  DATA 72,65
0015E:  DATA 63,74
00160:  DATA 6F,00
00162:  DATA 49,6E
00164:  DATA 67,72
00166:  DATA 65,73
00168:  DATA 61,20
0016A:  DATA 65,6C
0016C:  DATA 20,73
0016E:  DATA 65,67
00170:  DATA 75,6E
00172:  DATA 64,6F
00174:  DATA 20,6F
00176:  DATA 70,65
00178:  DATA 72,61
0017A:  DATA 6E,64
0017C:  DATA 6F,20
0017E:  DATA 0D,00
00180:  DATA 44,61
00182:  DATA 74,6F
00184:  DATA 20,69
00186:  DATA 6E,63
00188:  DATA 6F,72
0018A:  DATA 72,65
0018C:  DATA 63,74
0018E:  DATA 6F,00
00190:  DATA 53,65
00192:  DATA 6C,65
00194:  DATA 63,63
00196:  DATA 69,6F
00198:  DATA 6E,65
0019A:  DATA 20,75
0019C:  DATA 6E,61
0019E:  DATA 20,6F
001A0:  DATA 70,65
001A2:  DATA 72,61
001A4:  DATA 63,69
001A6:  DATA 6F,6E
001A8:  DATA 3A,20
001AA:  DATA 0D,20
001AC:  DATA 31,29
001AE:  DATA 53,75
001B0:  DATA 6D,61
001B2:  DATA 20,20
001B4:  DATA 32,29
001B6:  DATA 52,65
001B8:  DATA 73,74
001BA:  DATA 61,20
001BC:  DATA 20,33
001BE:  DATA 29,4D
001C0:  DATA 75,6C
001C2:  DATA 74,69
001C4:  DATA 70,6C
001C6:  DATA 69,63
001C8:  DATA 61,63
001CA:  DATA 69,6F
001CC:  DATA 6E,20
001CE:  DATA 20,34
001D0:  DATA 29,44
001D2:  DATA 69,76
001D4:  DATA 69,73
001D6:  DATA 69,6F
001D8:  DATA 6E,20
001DA:  DATA 0D,00
001DC:  DATA 45,6C
001DE:  DATA 20,72
001E0:  DATA 65,73
001E2:  DATA 75,6C
001E4:  DATA 74,61
001E6:  DATA 64,6F
001E8:  DATA 20,64
001EA:  DATA 65,20
001EC:  DATA 6C,61
001EE:  DATA 20,6F
001F0:  DATA 70,65
001F2:  DATA 72,61
001F4:  DATA 63,69
001F6:  DATA 6F,6E
001F8:  DATA 20,65
001FA:  DATA 73,3A
001FC:  DATA 20,25
001FE:  DATA 34,2E
00200:  DATA 34,66
00202:  DATA 0D,0D
00204:  DATA 00,00
*
00226:  TBLRD*+
00228:  MOVF   FF5,F
0022A:  BZ    0246
0022C:  MOVFF  FF6,36
00230:  MOVFF  FF7,37
00234:  MOVF   FF5,W
00236:  BTFSS  F9E.4
00238:  BRA    0236
0023A:  MOVWF  FAD
0023C:  MOVFF  36,FF6
00240:  MOVFF  37,FF7
00244:  BRA    0226
00246:  RETURN 0
00248:  MOVF   45,W
0024A:  BTFSC  FD8.2
0024C:  BRA    0330
0024E:  MOVWF  00
00250:  MOVF   49,W
00252:  BTFSC  FD8.2
00254:  BRA    0330
00256:  ADDWF  00,F
00258:  BNC   0262
0025A:  MOVLW  81
0025C:  ADDWF  00,F
0025E:  BC    0330
00260:  BRA    026A
00262:  MOVLW  7F
00264:  SUBWF  00,F
00266:  BNC   0330
00268:  BZ    0330
0026A:  MOVFF  46,4D
0026E:  MOVF   4A,W
00270:  XORWF  4D,F
00272:  BSF    46.7
00274:  BSF    4A.7
00276:  MOVF   48,W
00278:  MULWF  4C
0027A:  MOVFF  FF4,4F
0027E:  MOVF   47,W
00280:  MULWF  4B
00282:  MOVFF  FF4,03
00286:  MOVFF  FF3,4E
0028A:  MULWF  4C
0028C:  MOVF   FF3,W
0028E:  ADDWF  4F,F
00290:  MOVF   FF4,W
00292:  ADDWFC 4E,F
00294:  MOVLW  00
00296:  ADDWFC 03,F
00298:  MOVF   48,W
0029A:  MULWF  4B
0029C:  MOVF   FF3,W
0029E:  ADDWF  4F,F
002A0:  MOVF   FF4,W
002A2:  ADDWFC 4E,F
002A4:  MOVLW  00
002A6:  CLRF   02
002A8:  ADDWFC 03,F
002AA:  ADDWFC 02,F
002AC:  MOVF   46,W
002AE:  MULWF  4C
002B0:  MOVF   FF3,W
002B2:  ADDWF  4E,F
002B4:  MOVF   FF4,W
002B6:  ADDWFC 03,F
002B8:  MOVLW  00
002BA:  ADDWFC 02,F
002BC:  MOVF   46,W
002BE:  MULWF  4B
002C0:  MOVF   FF3,W
002C2:  ADDWF  03,F
002C4:  MOVF   FF4,W
002C6:  ADDWFC 02,F
002C8:  MOVLW  00
002CA:  CLRF   01
002CC:  ADDWFC 01,F
002CE:  MOVF   48,W
002D0:  MULWF  4A
002D2:  MOVF   FF3,W
002D4:  ADDWF  4E,F
002D6:  MOVF   FF4,W
002D8:  ADDWFC 03,F
002DA:  MOVLW  00
002DC:  ADDWFC 02,F
002DE:  ADDWFC 01,F
002E0:  MOVF   47,W
002E2:  MULWF  4A
002E4:  MOVF   FF3,W
002E6:  ADDWF  03,F
002E8:  MOVF   FF4,W
002EA:  ADDWFC 02,F
002EC:  MOVLW  00
002EE:  ADDWFC 01,F
002F0:  MOVF   46,W
002F2:  MULWF  4A
002F4:  MOVF   FF3,W
002F6:  ADDWF  02,F
002F8:  MOVF   FF4,W
002FA:  ADDWFC 01,F
002FC:  INCF   00,F
002FE:  BTFSC  01.7
00300:  BRA    030C
00302:  RLCF   4E,F
00304:  RLCF   03,F
00306:  RLCF   02,F
00308:  RLCF   01,F
0030A:  DECF   00,F
0030C:  MOVLW  00
0030E:  BTFSS  4E.7
00310:  BRA    0326
00312:  INCF   03,F
00314:  ADDWFC 02,F
00316:  ADDWFC 01,F
00318:  MOVF   01,W
0031A:  BNZ   0326
0031C:  MOVF   02,W
0031E:  BNZ   0326
00320:  MOVF   03,W
00322:  BNZ   0326
00324:  INCF   00,F
00326:  BTFSC  4D.7
00328:  BSF    01.7
0032A:  BTFSS  4D.7
0032C:  BCF    01.7
0032E:  BRA    0338
00330:  CLRF   00
00332:  CLRF   01
00334:  CLRF   02
00336:  CLRF   03
00338:  RETURN 0
0033A:  MOVLW  8E
0033C:  MOVWF  00
0033E:  MOVFF  4A,01
00342:  MOVFF  49,02
00346:  CLRF   03
00348:  MOVF   01,F
0034A:  BNZ   035E
0034C:  MOVFF  02,01
00350:  CLRF   02
00352:  MOVLW  08
00354:  SUBWF  00,F
00356:  MOVF   01,F
00358:  BNZ   035E
0035A:  CLRF   00
0035C:  BRA    036E
0035E:  BCF    FD8.0
00360:  BTFSC  01.7
00362:  BRA    036C
00364:  RLCF   02,F
00366:  RLCF   01,F
00368:  DECF   00,F
0036A:  BRA    035E
0036C:  BCF    01.7
0036E:  RETURN 0
00370:  MOVF   49,W
00372:  BTFSC  FD8.2
00374:  BRA    04C0
00376:  MOVWF  55
00378:  MOVF   4D,W
0037A:  BTFSC  FD8.2
0037C:  BRA    04C0
0037E:  SUBWF  55,F
00380:  BNC   038C
00382:  MOVLW  7F
00384:  ADDWF  55,F
00386:  BTFSC  FD8.0
00388:  BRA    04C0
0038A:  BRA    0398
0038C:  MOVLW  81
0038E:  SUBWF  55,F
00390:  BTFSS  FD8.0
00392:  BRA    04C0
00394:  BTFSC  FD8.2
00396:  BRA    04C0
00398:  MOVFF  55,00
0039C:  CLRF   01
0039E:  CLRF   02
003A0:  CLRF   03
003A2:  CLRF   54
003A4:  MOVFF  4A,53
003A8:  BSF    53.7
003AA:  MOVFF  4B,52
003AE:  MOVFF  4C,51
003B2:  MOVLW  19
003B4:  MOVWF  55
003B6:  MOVF   50,W
003B8:  SUBWF  51,F
003BA:  BC    03D6
003BC:  MOVLW  01
003BE:  SUBWF  52,F
003C0:  BC    03D6
003C2:  SUBWF  53,F
003C4:  BC    03D6
003C6:  SUBWF  54,F
003C8:  BC    03D6
003CA:  INCF   54,F
003CC:  INCF   53,F
003CE:  INCF   52,F
003D0:  MOVF   50,W
003D2:  ADDWF  51,F
003D4:  BRA    0426
003D6:  MOVF   4F,W
003D8:  SUBWF  52,F
003DA:  BC    0400
003DC:  MOVLW  01
003DE:  SUBWF  53,F
003E0:  BC    0400
003E2:  SUBWF  54,F
003E4:  BC    0400
003E6:  INCF   54,F
003E8:  INCF   53,F
003EA:  MOVF   4F,W
003EC:  ADDWF  52,F
003EE:  MOVF   50,W
003F0:  ADDWF  51,F
003F2:  BNC   0426
003F4:  INCF   52,F
003F6:  BNZ   0426
003F8:  INCF   53,F
003FA:  BNZ   0426
003FC:  INCF   54,F
003FE:  BRA    0426
00400:  MOVF   4E,W
00402:  IORLW  80
00404:  SUBWF  53,F
00406:  BC    0424
00408:  MOVLW  01
0040A:  SUBWF  54,F
0040C:  BC    0424
0040E:  INCF   54,F
00410:  MOVF   4E,W
00412:  IORLW  80
00414:  ADDWF  53,F
00416:  MOVF   4F,W
00418:  ADDWF  52,F
0041A:  BNC   03EE
0041C:  INCF   53,F
0041E:  BNZ   03EE
00420:  INCF   54,F
00422:  BRA    03EE
00424:  BSF    03.0
00426:  DECFSZ 55,F
00428:  BRA    042C
0042A:  BRA    0442
0042C:  BCF    FD8.0
0042E:  RLCF   51,F
00430:  RLCF   52,F
00432:  RLCF   53,F
00434:  RLCF   54,F
00436:  BCF    FD8.0
00438:  RLCF   03,F
0043A:  RLCF   02,F
0043C:  RLCF   01,F
0043E:  RLCF   56,F
00440:  BRA    03B6
00442:  BTFSS  56.0
00444:  BRA    0452
00446:  BCF    FD8.0
00448:  RRCF   01,F
0044A:  RRCF   02,F
0044C:  RRCF   03,F
0044E:  RRCF   56,F
00450:  BRA    0456
00452:  DECF   00,F
00454:  BZ    04C0
00456:  BTFSC  56.7
00458:  BRA    0496
0045A:  BCF    FD8.0
0045C:  RLCF   51,F
0045E:  RLCF   52,F
00460:  RLCF   53,F
00462:  RLCF   54,F
00464:  MOVF   50,W
00466:  SUBWF  51,F
00468:  BC    0478
0046A:  MOVLW  01
0046C:  SUBWF  52,F
0046E:  BC    0478
00470:  SUBWF  53,F
00472:  BC    0478
00474:  SUBWF  54,F
00476:  BNC   04AC
00478:  MOVF   4F,W
0047A:  SUBWF  52,F
0047C:  BC    0488
0047E:  MOVLW  01
00480:  SUBWF  53,F
00482:  BC    0488
00484:  SUBWF  54,F
00486:  BNC   04AC
00488:  MOVF   4E,W
0048A:  IORLW  80
0048C:  SUBWF  53,F
0048E:  BC    0496
00490:  MOVLW  01
00492:  SUBWF  54,F
00494:  BNC   04AC
00496:  INCF   03,F
00498:  BNZ   04AC
0049A:  INCF   02,F
0049C:  BNZ   04AC
0049E:  INCF   01,F
004A0:  BNZ   04AC
004A2:  INCF   00,F
004A4:  BZ    04C0
004A6:  RRCF   01,F
004A8:  RRCF   02,F
004AA:  RRCF   03,F
004AC:  MOVFF  4A,55
004B0:  MOVF   4E,W
004B2:  XORWF  55,F
004B4:  BTFSS  55.7
004B6:  BRA    04BC
004B8:  BSF    01.7
004BA:  BRA    04C8
004BC:  BCF    01.7
004BE:  BRA    04C8
004C0:  CLRF   00
004C2:  CLRF   01
004C4:  CLRF   02
004C6:  CLRF   03
004C8:  RETURN 0
004CA:  MOVLW  80
004CC:  BTFSC  FD8.1
004CE:  XORWF  4E,F
004D0:  CLRF   53
004D2:  CLRF   54
004D4:  MOVFF  4A,52
004D8:  MOVF   4E,W
004DA:  XORWF  52,F
004DC:  MOVF   49,W
004DE:  BTFSC  FD8.2
004E0:  BRA    069A
004E2:  MOVWF  51
004E4:  MOVWF  00
004E6:  MOVF   4D,W
004E8:  BTFSC  FD8.2
004EA:  BRA    06AC
004EC:  SUBWF  51,F
004EE:  BTFSC  FD8.2
004F0:  BRA    05F4
004F2:  BNC   056E
004F4:  MOVFF  4E,57
004F8:  BSF    57.7
004FA:  MOVFF  4F,56
004FE:  MOVFF  50,55
00502:  CLRF   54
00504:  BCF    FD8.0
00506:  RRCF   57,F
00508:  RRCF   56,F
0050A:  RRCF   55,F
0050C:  RRCF   54,F
0050E:  DECFSZ 51,F
00510:  BRA    0502
00512:  BTFSS  52.7
00514:  BRA    051C
00516:  BSF    53.0
00518:  BRA    06D4
0051A:  BCF    53.0
0051C:  BCF    51.0
0051E:  BSF    53.4
00520:  CLRF   FEA
00522:  MOVLW  4C
00524:  MOVWF  FE9
00526:  BRA    06FA
00528:  BCF    53.4
0052A:  BTFSC  52.7
0052C:  BRA    0542
0052E:  BTFSS  51.0
00530:  BRA    0558
00532:  RRCF   57,F
00534:  RRCF   56,F
00536:  RRCF   55,F
00538:  RRCF   54,F
0053A:  INCF   00,F
0053C:  BTFSC  FD8.2
0053E:  BRA    06CA
00540:  BRA    0558
00542:  BTFSC  57.7
00544:  BRA    055E
00546:  BCF    FD8.0
00548:  RLCF   54,F
0054A:  RLCF   55,F
0054C:  RLCF   56,F
0054E:  RLCF   57,F
00550:  DECF   00,F
00552:  BTFSC  FD8.2
00554:  BRA    06CA
00556:  BRA    0542
00558:  BSF    53.6
0055A:  BRA    0632
0055C:  BCF    53.6
0055E:  MOVFF  4A,52
00562:  BTFSS  4A.7
00564:  BRA    056A
00566:  BSF    57.7
00568:  BRA    06BC
0056A:  BCF    57.7
0056C:  BRA    06BC
0056E:  MOVFF  4D,51
00572:  MOVFF  4D,00
00576:  MOVF   49,W
00578:  SUBWF  51,F
0057A:  MOVFF  4A,57
0057E:  BSF    57.7
00580:  MOVFF  4B,56
00584:  MOVFF  4C,55
00588:  CLRF   54
0058A:  BCF    FD8.0
0058C:  RRCF   57,F
0058E:  RRCF   56,F
00590:  RRCF   55,F
00592:  RRCF   54,F
00594:  DECFSZ 51,F
00596:  BRA    0588
00598:  BTFSS  52.7
0059A:  BRA    05A2
0059C:  BSF    53.1
0059E:  BRA    06D4
005A0:  BCF    53.1
005A2:  BCF    51.0
005A4:  BSF    53.5
005A6:  CLRF   FEA
005A8:  MOVLW  50
005AA:  MOVWF  FE9
005AC:  BRA    06FA
005AE:  BCF    53.5
005B0:  BTFSC  52.7
005B2:  BRA    05C8
005B4:  BTFSS  51.0
005B6:  BRA    05DE
005B8:  RRCF   57,F
005BA:  RRCF   56,F
005BC:  RRCF   55,F
005BE:  RRCF   54,F
005C0:  INCF   00,F
005C2:  BTFSC  FD8.2
005C4:  BRA    06CA
005C6:  BRA    05DE
005C8:  BTFSC  57.7
005CA:  BRA    05E4
005CC:  BCF    FD8.0
005CE:  RLCF   54,F
005D0:  RLCF   55,F
005D2:  RLCF   56,F
005D4:  RLCF   57,F
005D6:  DECF   00,F
005D8:  BTFSC  FD8.2
005DA:  BRA    06CA
005DC:  BRA    05C8
005DE:  BSF    53.7
005E0:  BRA    0632
005E2:  BCF    53.7
005E4:  MOVFF  4E,52
005E8:  BTFSS  4E.7
005EA:  BRA    05F0
005EC:  BSF    57.7
005EE:  BRA    06BC
005F0:  BCF    57.7
005F2:  BRA    06BC
005F4:  MOVFF  4E,57
005F8:  BSF    57.7
005FA:  MOVFF  4F,56
005FE:  MOVFF  50,55
00602:  BTFSS  52.7
00604:  BRA    060E
00606:  BCF    57.7
00608:  BSF    53.2
0060A:  BRA    06D4
0060C:  BCF    53.2
0060E:  CLRF   54
00610:  BCF    51.0
00612:  CLRF   FEA
00614:  MOVLW  4C
00616:  MOVWF  FE9
00618:  BRA    06FA
0061A:  BTFSC  52.7
0061C:  BRA    0656
0061E:  MOVFF  4A,52
00622:  BTFSS  51.0
00624:  BRA    0632
00626:  RRCF   57,F
00628:  RRCF   56,F
0062A:  RRCF   55,F
0062C:  RRCF   54,F
0062E:  INCF   00,F
00630:  BZ    06CA
00632:  BTFSS  54.7
00634:  BRA    064C
00636:  INCF   55,F
00638:  BNZ   064C
0063A:  INCF   56,F
0063C:  BNZ   064C
0063E:  INCF   57,F
00640:  BNZ   064C
00642:  RRCF   57,F
00644:  RRCF   56,F
00646:  RRCF   55,F
00648:  INCF   00,F
0064A:  BZ    06CA
0064C:  BTFSC  53.6
0064E:  BRA    055C
00650:  BTFSC  53.7
00652:  BRA    05E2
00654:  BRA    068E
00656:  MOVLW  80
00658:  XORWF  57,F
0065A:  BTFSS  57.7
0065C:  BRA    0666
0065E:  BRA    06D4
00660:  MOVFF  4E,52
00664:  BRA    067A
00666:  MOVFF  4A,52
0066A:  MOVF   57,F
0066C:  BNZ   067A
0066E:  MOVF   56,F
00670:  BNZ   067A
00672:  MOVF   55,F
00674:  BNZ   067A
00676:  CLRF   00
00678:  BRA    06BC
0067A:  BTFSC  57.7
0067C:  BRA    068E
0067E:  BCF    FD8.0
00680:  RLCF   54,F
00682:  RLCF   55,F
00684:  RLCF   56,F
00686:  RLCF   57,F
00688:  DECFSZ 00,F
0068A:  BRA    067A
0068C:  BRA    06CA
0068E:  BTFSS  52.7
00690:  BRA    0696
00692:  BSF    57.7
00694:  BRA    06BC
00696:  BCF    57.7
00698:  BRA    06BC
0069A:  MOVFF  4D,00
0069E:  MOVFF  4E,57
006A2:  MOVFF  4F,56
006A6:  MOVFF  50,55
006AA:  BRA    06BC
006AC:  MOVFF  49,00
006B0:  MOVFF  4A,57
006B4:  MOVFF  4B,56
006B8:  MOVFF  4C,55
006BC:  MOVFF  57,01
006C0:  MOVFF  56,02
006C4:  MOVFF  55,03
006C8:  BRA    0732
006CA:  CLRF   00
006CC:  CLRF   01
006CE:  CLRF   02
006D0:  CLRF   03
006D2:  BRA    0732
006D4:  CLRF   54
006D6:  COMF   55,F
006D8:  COMF   56,F
006DA:  COMF   57,F
006DC:  COMF   54,F
006DE:  INCF   54,F
006E0:  BNZ   06EC
006E2:  INCF   55,F
006E4:  BNZ   06EC
006E6:  INCF   56,F
006E8:  BNZ   06EC
006EA:  INCF   57,F
006EC:  BTFSC  53.0
006EE:  BRA    051A
006F0:  BTFSC  53.1
006F2:  BRA    05A0
006F4:  BTFSC  53.2
006F6:  BRA    060C
006F8:  BRA    0660
006FA:  MOVF   FEF,W
006FC:  ADDWF  55,F
006FE:  BNC   070A
00700:  INCF   56,F
00702:  BNZ   070A
00704:  INCF   57,F
00706:  BTFSC  FD8.2
00708:  BSF    51.0
0070A:  MOVF   FED,F
0070C:  MOVF   FEF,W
0070E:  ADDWF  56,F
00710:  BNC   0718
00712:  INCF   57,F
00714:  BTFSC  FD8.2
00716:  BSF    51.0
00718:  MOVF   FED,F
0071A:  MOVF   FEF,W
0071C:  BTFSC  FEF.7
0071E:  BRA    0722
00720:  XORLW  80
00722:  ADDWF  57,F
00724:  BTFSC  FD8.0
00726:  BSF    51.0
00728:  BTFSC  53.4
0072A:  BRA    0528
0072C:  BTFSC  53.5
0072E:  BRA    05AE
00730:  BRA    061A
00732:  RETURN 0
*
00966:  MOVF   43,W
00968:  SUBLW  B6
0096A:  MOVWF  43
0096C:  CLRF   03
0096E:  MOVFF  44,47
00972:  BSF    44.7
00974:  BCF    FD8.0
00976:  RRCF   44,F
00978:  RRCF   45,F
0097A:  RRCF   46,F
0097C:  RRCF   03,F
0097E:  RRCF   02,F
00980:  RRCF   01,F
00982:  RRCF   00,F
00984:  DECFSZ 43,F
00986:  BRA    0974
00988:  BTFSS  47.7
0098A:  BRA    09A2
0098C:  COMF   00,F
0098E:  COMF   01,F
00990:  COMF   02,F
00992:  COMF   03,F
00994:  INCF   00,F
00996:  BTFSC  FD8.2
00998:  INCF   01,F
0099A:  BTFSC  FD8.2
0099C:  INCF   02,F
0099E:  BTFSC  FD8.2
009A0:  INCF   03,F
009A2:  GOTO   0A84 (RETURN)
009A6:  BTFSC  FD8.1
009A8:  BRA    09B0
009AA:  CLRF   FEA
009AC:  MOVLW  4B
009AE:  MOVWF  FE9
009B0:  CLRF   00
009B2:  CLRF   01
009B4:  CLRF   02
009B6:  CLRF   03
009B8:  CLRF   4B
009BA:  CLRF   4C
009BC:  CLRF   4D
009BE:  CLRF   4E
009C0:  MOVF   4A,W
009C2:  IORWF  49,W
009C4:  IORWF  48,W
009C6:  IORWF  47,W
009C8:  BZ    0A22
009CA:  MOVLW  20
009CC:  MOVWF  4F
009CE:  BCF    FD8.0
009D0:  RLCF   43,F
009D2:  RLCF   44,F
009D4:  RLCF   45,F
009D6:  RLCF   46,F
009D8:  RLCF   4B,F
009DA:  RLCF   4C,F
009DC:  RLCF   4D,F
009DE:  RLCF   4E,F
009E0:  MOVF   4A,W
009E2:  SUBWF  4E,W
009E4:  BNZ   09F6
009E6:  MOVF   49,W
009E8:  SUBWF  4D,W
009EA:  BNZ   09F6
009EC:  MOVF   48,W
009EE:  SUBWF  4C,W
009F0:  BNZ   09F6
009F2:  MOVF   47,W
009F4:  SUBWF  4B,W
009F6:  BNC   0A16
009F8:  MOVF   47,W
009FA:  SUBWF  4B,F
009FC:  MOVF   48,W
009FE:  BTFSS  FD8.0
00A00:  INCFSZ 48,W
00A02:  SUBWF  4C,F
00A04:  MOVF   49,W
00A06:  BTFSS  FD8.0
00A08:  INCFSZ 49,W
00A0A:  SUBWF  4D,F
00A0C:  MOVF   4A,W
00A0E:  BTFSS  FD8.0
00A10:  INCFSZ 4A,W
00A12:  SUBWF  4E,F
00A14:  BSF    FD8.0
00A16:  RLCF   00,F
00A18:  RLCF   01,F
00A1A:  RLCF   02,F
00A1C:  RLCF   03,F
00A1E:  DECFSZ 4F,F
00A20:  BRA    09CE
00A22:  MOVFF  4B,FEF
00A26:  MOVFF  4C,FEC
00A2A:  MOVFF  4D,FEC
00A2E:  MOVFF  4E,FEC
00A32:  RETURN 0
00A34:  MOVF   FE9,W
00A36:  MOVWF  3B
00A38:  MOVF   3A,W
00A3A:  MOVWF  3D
00A3C:  BZ    0A72
00A3E:  MOVFF  39,48
00A42:  MOVFF  38,47
00A46:  MOVFF  37,46
00A4A:  MOVFF  36,45
00A4E:  CLRF   4C
00A50:  CLRF   4B
00A52:  MOVLW  20
00A54:  MOVWF  4A
00A56:  MOVLW  82
00A58:  MOVWF  49
00A5A:  CALL   0248
00A5E:  MOVFF  03,39
00A62:  MOVFF  02,38
00A66:  MOVFF  01,37
00A6A:  MOVFF  00,36
00A6E:  DECFSZ 3D,F
00A70:  BRA    0A3E
00A72:  MOVFF  39,46
00A76:  MOVFF  38,45
00A7A:  MOVFF  37,44
00A7E:  MOVFF  36,43
00A82:  BRA    0966
00A84:  MOVFF  03,39
00A88:  MOVFF  02,38
00A8C:  MOVFF  01,37
00A90:  MOVFF  00,36
00A94:  BTFSS  39.7
00A96:  BRA    0AB2
00A98:  DECF   3B,F
00A9A:  BSF    3B.5
00A9C:  COMF   36,F
00A9E:  COMF   37,F
00AA0:  COMF   38,F
00AA2:  COMF   39,F
00AA4:  INCF   36,F
00AA6:  BTFSC  FD8.2
00AA8:  INCF   37,F
00AAA:  BTFSC  FD8.2
00AAC:  INCF   38,F
00AAE:  BTFSC  FD8.2
00AB0:  INCF   39,F
00AB2:  MOVLW  3B
00AB4:  MOVWF  42
00AB6:  MOVLW  9A
00AB8:  MOVWF  41
00ABA:  MOVLW  CA
00ABC:  MOVWF  40
00ABE:  CLRF   3F
00AC0:  MOVLW  0A
00AC2:  MOVWF  3D
00AC4:  MOVF   3A,W
00AC6:  BTFSC  FD8.2
00AC8:  INCF   3B,F
00ACA:  BSF    FD8.1
00ACC:  CLRF   FEA
00ACE:  MOVLW  36
00AD0:  MOVWF  FE9
00AD2:  MOVFF  39,46
00AD6:  MOVFF  38,45
00ADA:  MOVFF  37,44
00ADE:  MOVFF  36,43
00AE2:  MOVFF  42,4A
00AE6:  MOVFF  41,49
00AEA:  MOVFF  40,48
00AEE:  MOVFF  3F,47
00AF2:  RCALL  09A6
00AF4:  MOVF   01,W
00AF6:  MOVF   00,F
00AF8:  BNZ   0B18
00AFA:  INCF   3A,W
00AFC:  SUBWF  3D,W
00AFE:  BZ    0B18
00B00:  MOVF   3B,W
00B02:  BZ    0B1C
00B04:  ANDLW  0F
00B06:  SUBWF  3D,W
00B08:  BZ    0B0C
00B0A:  BC    0B82
00B0C:  BTFSC  3B.7
00B0E:  BRA    0B82
00B10:  BTFSC  3B.6
00B12:  BRA    0B1C
00B14:  MOVLW  20
00B16:  BRA    0B78
00B18:  MOVLW  20
00B1A:  ANDWF  3B,F
00B1C:  BTFSS  3B.5
00B1E:  BRA    0B3A
00B20:  BCF    3B.5
00B22:  MOVF   3A,W
00B24:  BTFSS  FD8.2
00B26:  DECF   3B,F
00B28:  MOVF   00,W
00B2A:  MOVWF  3B
00B2C:  MOVLW  2D
00B2E:  BTFSS  F9E.4
00B30:  BRA    0B2E
00B32:  MOVWF  FAD
00B34:  MOVF   3B,W
00B36:  MOVWF  00
00B38:  CLRF   3B
00B3A:  MOVF   3A,W
00B3C:  SUBWF  3D,W
00B3E:  BNZ   0B56
00B40:  MOVF   00,W
00B42:  MOVWF  3B
00B44:  MOVLW  2E
00B46:  BTFSS  F9E.4
00B48:  BRA    0B46
00B4A:  MOVWF  FAD
00B4C:  MOVF   3B,W
00B4E:  MOVWF  00
00B50:  MOVLW  20
00B52:  ANDWF  3B,F
00B54:  MOVLW  00
00B56:  MOVLW  30
00B58:  BTFSS  3B.5
00B5A:  BRA    0B78
00B5C:  BCF    3B.5
00B5E:  MOVF   3A,W
00B60:  BTFSS  FD8.2
00B62:  DECF   3B,F
00B64:  MOVF   00,W
00B66:  MOVWF  3B
00B68:  MOVLW  2D
00B6A:  BTFSS  F9E.4
00B6C:  BRA    0B6A
00B6E:  MOVWF  FAD
00B70:  MOVF   3B,W
00B72:  MOVWF  00
00B74:  CLRF   3B
00B76:  MOVLW  30
00B78:  ADDWF  00,F
00B7A:  MOVF   00,W
00B7C:  BTFSS  F9E.4
00B7E:  BRA    0B7C
00B80:  MOVWF  FAD
00B82:  BCF    FD8.1
00B84:  MOVFF  42,46
00B88:  MOVFF  41,45
00B8C:  MOVFF  40,44
00B90:  MOVFF  3F,43
00B94:  CLRF   4A
00B96:  CLRF   49
00B98:  CLRF   48
00B9A:  MOVLW  0A
00B9C:  MOVWF  47
00B9E:  RCALL  09A6
00BA0:  MOVFF  03,42
00BA4:  MOVFF  02,41
00BA8:  MOVFF  01,40
00BAC:  MOVFF  00,3F
00BB0:  DECFSZ 3D,F
00BB2:  BRA    0ACA
00BB4:  RETURN 0
00BB6:  TBLRD*+
00BB8:  MOVFF  FF6,37
00BBC:  MOVFF  FF7,38
00BC0:  MOVF   FF5,W
00BC2:  BTFSS  F9E.4
00BC4:  BRA    0BC2
00BC6:  MOVWF  FAD
00BC8:  MOVFF  37,FF6
00BCC:  MOVFF  38,FF7
00BD0:  DECFSZ 36,F
00BD2:  BRA    0BB6
00BD4:  GOTO   0EDE (RETURN)
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
00734:  CLRF   3D
00736:  CLRF   3C
00738:  CLRF   3B
0073A:  MOVLW  7F
0073C:  MOVWF  3A
0073E:  CLRF   41
00740:  CLRF   40
00742:  CLRF   3F
00744:  CLRF   3E
00746:  BSF    42.0
00748:  BCF    42.1
0074A:  BCF    42.2
0074C:  CLRF   44
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0074E:  MOVF   36,W
00750:  IORWF  37,W
00752:  BNZ   075E
....................       return 0; 
00754:  CLRF   00
00756:  CLRF   01
00758:  CLRF   02
0075A:  CLRF   03
0075C:  BRA    0964
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0075E:  MOVF   44,W
00760:  INCF   44,F
00762:  CLRF   03
00764:  ADDWF  36,W
00766:  MOVWF  FE9
00768:  MOVF   37,W
0076A:  ADDWFC 03,W
0076C:  MOVWF  FEA
0076E:  MOVFF  FEF,43
00772:  MOVF   43,F
00774:  BTFSC  FD8.2
00776:  BRA    08EE
....................    { 
....................       if (skip && !isspace(c)) 
00778:  BTFSS  42.0
0077A:  BRA    079A
0077C:  MOVF   43,W
0077E:  SUBLW  20
00780:  BZ    079A
....................       { 
....................          skip = 0; 
00782:  BCF    42.0
....................          if (c == '+') 
00784:  MOVF   43,W
00786:  SUBLW  2B
00788:  BNZ   0790
....................          { 
....................             sign = 0; 
0078A:  BCF    42.1
....................             continue; 
0078C:  BRA    08D8
....................          }             
0078E:  BRA    079A
....................          else if (c == '-') 
00790:  MOVF   43,W
00792:  SUBLW  2D
00794:  BNZ   079A
....................          { 
....................             sign = 1; 
00796:  BSF    42.1
....................             continue; 
00798:  BRA    08D8
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0079A:  BTFSC  42.0
0079C:  BRA    07AC
0079E:  MOVF   43,W
007A0:  SUBLW  2E
007A2:  BNZ   07AC
007A4:  BTFSC  42.2
007A6:  BRA    07AC
....................          point = 1; 
007A8:  BSF    42.2
007AA:  BRA    08D8
....................       else if (!skip && isdigit(c)) 
007AC:  BTFSC  42.0
007AE:  BRA    08D2
007B0:  MOVF   43,W
007B2:  SUBLW  2F
007B4:  BTFSC  FD8.0
007B6:  BRA    08D2
007B8:  MOVF   43,W
007BA:  SUBLW  39
007BC:  BTFSS  FD8.0
007BE:  BRA    08D2
....................       { 
....................          c -= '0'; 
007C0:  MOVLW  30
007C2:  SUBWF  43,F
....................          if (point) 
007C4:  BTFSS  42.2
007C6:  BRA    0866
....................          { 
....................             pow10 = pow10 * 10.0; 
007C8:  MOVFF  3D,48
007CC:  MOVFF  3C,47
007D0:  MOVFF  3B,46
007D4:  MOVFF  3A,45
007D8:  CLRF   4C
007DA:  CLRF   4B
007DC:  MOVLW  20
007DE:  MOVWF  4A
007E0:  MOVLW  82
007E2:  MOVWF  49
007E4:  RCALL  0248
007E6:  MOVFF  03,3D
007EA:  MOVFF  02,3C
007EE:  MOVFF  01,3B
007F2:  MOVFF  00,3A
....................             result += (float)c / pow10;    
007F6:  CLRF   4A
007F8:  MOVFF  43,49
007FC:  RCALL  033A
007FE:  MOVFF  03,48
00802:  MOVFF  02,47
00806:  MOVFF  01,46
0080A:  MOVFF  00,45
0080E:  MOVFF  03,4C
00812:  MOVFF  02,4B
00816:  MOVFF  01,4A
0081A:  MOVFF  00,49
0081E:  MOVFF  3D,50
00822:  MOVFF  3C,4F
00826:  MOVFF  3B,4E
0082A:  MOVFF  3A,4D
0082E:  RCALL  0370
00830:  BCF    FD8.1
00832:  MOVFF  41,4C
00836:  MOVFF  40,4B
0083A:  MOVFF  3F,4A
0083E:  MOVFF  3E,49
00842:  MOVFF  03,50
00846:  MOVFF  02,4F
0084A:  MOVFF  01,4E
0084E:  MOVFF  00,4D
00852:  RCALL  04CA
00854:  MOVFF  03,41
00858:  MOVFF  02,40
0085C:  MOVFF  01,3F
00860:  MOVFF  00,3E
....................          } 
00864:  BRA    08D0
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
00866:  CLRF   48
00868:  CLRF   47
0086A:  MOVLW  20
0086C:  MOVWF  46
0086E:  MOVLW  82
00870:  MOVWF  45
00872:  MOVFF  41,4C
00876:  MOVFF  40,4B
0087A:  MOVFF  3F,4A
0087E:  MOVFF  3E,49
00882:  RCALL  0248
00884:  MOVFF  03,48
00888:  MOVFF  02,47
0088C:  MOVFF  01,46
00890:  MOVFF  00,45
00894:  CLRF   4A
00896:  MOVFF  43,49
0089A:  RCALL  033A
0089C:  BCF    FD8.1
0089E:  MOVFF  48,4C
008A2:  MOVFF  47,4B
008A6:  MOVFF  46,4A
008AA:  MOVFF  45,49
008AE:  MOVFF  03,50
008B2:  MOVFF  02,4F
008B6:  MOVFF  01,4E
008BA:  MOVFF  00,4D
008BE:  RCALL  04CA
008C0:  MOVFF  03,41
008C4:  MOVFF  02,40
008C8:  MOVFF  01,3F
008CC:  MOVFF  00,3E
....................          } 
....................       } 
008D0:  BRA    08D8
....................       else if (!skip) 
008D2:  BTFSC  42.0
008D4:  BRA    08D8
....................          break; 
008D6:  BRA    08EE
008D8:  MOVF   44,W
008DA:  INCF   44,F
008DC:  CLRF   03
008DE:  ADDWF  36,W
008E0:  MOVWF  FE9
008E2:  MOVF   37,W
008E4:  ADDWFC 03,W
008E6:  MOVWF  FEA
008E8:  MOVFF  FEF,43
008EC:  BRA    0772
....................    } 
....................  
....................    if (sign) 
008EE:  BTFSS  42.1
008F0:  BRA    0920
....................       result = -1*result; 
008F2:  CLRF   48
008F4:  CLRF   47
008F6:  MOVLW  80
008F8:  MOVWF  46
008FA:  MOVLW  7F
008FC:  MOVWF  45
008FE:  MOVFF  41,4C
00902:  MOVFF  40,4B
00906:  MOVFF  3F,4A
0090A:  MOVFF  3E,49
0090E:  RCALL  0248
00910:  MOVFF  03,41
00914:  MOVFF  02,40
00918:  MOVFF  01,3F
0091C:  MOVFF  00,3E
....................        
....................    if(endptr) 
00920:  MOVF   38,W
00922:  IORWF  39,W
00924:  BZ    0954
....................    { 
....................       if (ptr) { 
00926:  MOVF   44,F
00928:  BZ    0942
....................          ptr--; 
0092A:  DECF   44,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0092C:  MOVFF  38,FE9
00930:  MOVFF  39,FEA
00934:  MOVF   44,W
00936:  ADDWF  36,W
00938:  MOVWF  FEF
0093A:  MOVLW  00
0093C:  ADDWFC 37,W
0093E:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
00940:  BRA    0954
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
00942:  MOVFF  38,FE9
00946:  MOVFF  39,FEA
0094A:  MOVFF  37,FEC
0094E:  MOVF   FED,F
00950:  MOVFF  36,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
00954:  MOVFF  3E,00
00958:  MOVFF  3F,01
0095C:  MOVFF  40,02
00960:  MOVFF  41,03
00964:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #fuses INTRC_IO, NOFCMEN, NOIESO, PUT, NOBROWNOUT, NOWDT  
.................... #fuses NOPBADEN, NOMCLR, STVREN, NOLVP, NODEBUG 
.................... #use delay(clock=16000000) 
.................... #use RS232(BAUD=9600,BITS=8,PARITY=N,XMIT=PIN_C6,RCV=PIN_C7,STOP=1)   
.................... #use standard_io(b) 
.................... #define tamanoBufer 11 
.................... //Variables globales 
.................... char Bufer[11]; 
.................... int banderaError=0; 
.................... int posicion=0; 
.................... #int_rda 
.................... void rda_isr() 
.................... {      
....................       banderaError=0; 
*
00096:  CLRF   27
....................       Bufer[posicion]=getc(); 
00098:  CLRF   03
0009A:  MOVF   28,W
0009C:  ADDLW  1C
0009E:  MOVWF  FE9
000A0:  MOVLW  00
000A2:  ADDWFC 03,W
000A4:  MOVWF  FEA
000A6:  BTFSS  F9E.5
000A8:  BRA    00A6
000AA:  MOVFF  FAE,FEF
....................       //Abilitar interrupcin TMR0        
....................       //enable_interrupts(int_TMR0); 
....................       //Resetear TMR0 "Desde donde va a correr"  
....................       //set_timer0(0); 
....................       if(((Bufer[posicion]<'0' && Bufer[posicion]>'9') && Bufer[posicion]!='-' && Bufer[posicion]!='.'))     //Si no ingreso un numero, un - o un .   El dato es incorrecto  
000AE:  CLRF   03
000B0:  MOVF   28,W
000B2:  ADDLW  1C
000B4:  MOVWF  FE9
000B6:  MOVLW  00
000B8:  ADDWFC 03,W
000BA:  MOVWF  FEA
000BC:  MOVF   FEF,W
000BE:  SUBLW  2F
000C0:  BNC   0102
000C2:  CLRF   03
000C4:  MOVF   28,W
000C6:  ADDLW  1C
000C8:  MOVWF  FE9
000CA:  MOVLW  00
000CC:  ADDWFC 03,W
000CE:  MOVWF  FEA
000D0:  MOVF   FEF,W
000D2:  SUBLW  39
000D4:  BC    0102
000D6:  CLRF   03
000D8:  MOVF   28,W
000DA:  ADDLW  1C
000DC:  MOVWF  FE9
000DE:  MOVLW  00
000E0:  ADDWFC 03,W
000E2:  MOVWF  FEA
000E4:  MOVF   FEF,W
000E6:  SUBLW  2D
000E8:  BZ    0102
000EA:  CLRF   03
000EC:  MOVF   28,W
000EE:  ADDLW  1C
000F0:  MOVWF  FE9
000F2:  MOVLW  00
000F4:  ADDWFC 03,W
000F6:  MOVWF  FEA
000F8:  MOVF   FEF,W
000FA:  SUBLW  2E
000FC:  BZ    0102
....................       { 
....................          banderaError=1; 
000FE:  MOVLW  01
00100:  MOVWF  27
....................       } 
....................    //Desabiitar interrupcin TMR0 
....................    posicion++; 
00102:  INCF   28,F
00104:  BCF    F9E.5
00106:  GOTO   0054
.................... } 
.................... void limpiarBufer(); 
.................... void main(void) 
*
00BD8:  CLRF   FF8
00BDA:  BCF    FD0.7
00BDC:  BSF    07.7
00BDE:  MOVLW  60
00BE0:  MOVWF  FD3
00BE2:  MOVLW  40
00BE4:  MOVWF  F9B
00BE6:  MOVF   FD3,W
00BE8:  BSF    FB8.3
00BEA:  MOVLW  A0
00BEC:  MOVWF  FAF
00BEE:  MOVLW  01
00BF0:  MOVWF  FB0
00BF2:  MOVLW  A6
00BF4:  MOVWF  FAC
00BF6:  MOVLW  90
00BF8:  MOVWF  FAB
00BFA:  CLRF   27
00BFC:  CLRF   28
00BFE:  MOVF   FC1,W
00C00:  ANDLW  C0
00C02:  IORLW  0F
00C04:  MOVWF  FC1
00C06:  MOVLW  07
00C08:  MOVWF  FB4
00C0A:  CLRF   16
00C0C:  CLRF   17
.................... { 
....................    //Configuraciones 
....................    setup_oscillator(OSC_16MHZ); 
00C0E:  MOVLW  60
00C10:  MOVWF  FD3
00C12:  MOVLW  40
00C14:  MOVWF  F9B
00C16:  MOVF   FD3,W
....................    enable_interrupts(global); 
00C18:  MOVLW  C0
00C1A:  IORWF  FF2,F
....................    enable_interrupts(int_rda); 
00C1C:  BSF    F9D.5
....................    SETUP_ADC_PORTS(NO_ANALOGS); 
00C1E:  MOVF   FC1,W
00C20:  ANDLW  C0
00C22:  IORLW  0F
00C24:  MOVWF  FC1
....................    //Variables 
....................    inicio:   //Punto de retorno 
....................     
....................    float primerOperando=0, segundoOperando=0, resultado=0; 
....................    char operacion='0'; 
00C26:  CLRF   2C
00C28:  CLRF   2B
00C2A:  CLRF   2A
00C2C:  CLRF   29
00C2E:  CLRF   30
00C30:  CLRF   2F
00C32:  CLRF   2E
00C34:  CLRF   2D
00C36:  CLRF   34
00C38:  CLRF   33
00C3A:  CLRF   32
00C3C:  CLRF   31
00C3E:  MOVLW  30
00C40:  MOVWF  35
....................    //// 
....................    while(true) 
....................    {    
....................       posicion=0; 
00C42:  CLRF   28
....................       limpiarBufer(); 
00C44:  CALL   0206
....................       //enable_interrupts(int_rda); 
....................       printf("Practica No. 4\r"); 
00C48:  MOVLW  0A
00C4A:  MOVWF  FF6
00C4C:  MOVLW  01
00C4E:  MOVWF  FF7
00C50:  CALL   0226
....................       printf("Calculadora Aritmetica \r\r"); 
00C54:  MOVLW  1A
00C56:  MOVWF  FF6
00C58:  MOVLW  01
00C5A:  MOVWF  FF7
00C5C:  CALL   0226
....................       printf("Ingresa el primer operando \r");    //Indica al usuario que ingrese el primer operando 
00C60:  MOVLW  34
00C62:  MOVWF  FF6
00C64:  MOVLW  01
00C66:  MOVWF  FF7
00C68:  CALL   0226
....................             
....................       while(/*(!kbhit()) || */((Bufer[posicion-1]!=0x0D) && (Bufer[posicion-1]!=0x0A) && (posicion-1<tamanoBufer)));                          //Toque de tecla 
00C6C:  MOVLW  01
00C6E:  SUBWF  28,W
00C70:  CLRF   03
00C72:  ADDLW  1C
00C74:  MOVWF  FE9
00C76:  MOVLW  00
00C78:  ADDWFC 03,W
00C7A:  MOVWF  FEA
00C7C:  MOVF   FEF,W
00C7E:  SUBLW  0D
00C80:  BZ    0CA0
00C82:  MOVLW  01
00C84:  SUBWF  28,W
00C86:  CLRF   03
00C88:  ADDLW  1C
00C8A:  MOVWF  FE9
00C8C:  MOVLW  00
00C8E:  ADDWFC 03,W
00C90:  MOVWF  FEA
00C92:  MOVF   FEF,W
00C94:  SUBLW  0A
00C96:  BZ    0CA0
00C98:  MOVLW  01
00C9A:  SUBWF  28,W
00C9C:  SUBLW  0A
00C9E:  BC    0C6C
....................       if(Bufer[posicion-1]==13)    Bufer[posicion-1]=0; 
00CA0:  MOVLW  01
00CA2:  SUBWF  28,W
00CA4:  CLRF   03
00CA6:  ADDLW  1C
00CA8:  MOVWF  FE9
00CAA:  MOVLW  00
00CAC:  ADDWFC 03,W
00CAE:  MOVWF  FEA
00CB0:  MOVF   FEF,W
00CB2:  SUBLW  0D
00CB4:  BNZ   0CC8
00CB6:  MOVLW  01
00CB8:  SUBWF  28,W
00CBA:  CLRF   03
00CBC:  ADDLW  1C
00CBE:  MOVWF  FE9
00CC0:  MOVLW  00
00CC2:  ADDWFC 03,W
00CC4:  MOVWF  FEA
00CC6:  CLRF   FEF
....................       if(banderaError) 
00CC8:  MOVF   27,F
00CCA:  BZ    0CDA
....................       { 
....................          printf("Dato incorrecto"); 
00CCC:  MOVLW  52
00CCE:  MOVWF  FF6
00CD0:  MOVLW  01
00CD2:  MOVWF  FF7
00CD4:  CALL   0226
....................          goto inicio; 
00CD8:  BRA    0C26
....................       } 
....................       posicion=0; 
00CDA:  CLRF   28
....................       primerOperando=atof(Bufer);                 //Asigna la cifra casteandola a un flotante, a primer operando en "primerOperando" 
00CDC:  CLRF   37
00CDE:  MOVLW  1C
00CE0:  MOVWF  36
00CE2:  CLRF   39
00CE4:  CLRF   38
00CE6:  RCALL  0734
00CE8:  MOVFF  03,2C
00CEC:  MOVFF  02,2B
00CF0:  MOVFF  01,2A
00CF4:  MOVFF  00,29
....................       limpiarBufer(); 
00CF8:  CALL   0206
....................       //enable_interrupts(int_rda); 
....................       printf("%4.4f\r",primerOperando);              //Muestra el operando ingresado 
00CFC:  MOVLW  89
00CFE:  MOVWF  FE9
00D00:  MOVFF  2C,39
00D04:  MOVFF  2B,38
00D08:  MOVFF  2A,37
00D0C:  MOVFF  29,36
00D10:  MOVLW  04
00D12:  MOVWF  3A
00D14:  RCALL  0A34
00D16:  MOVLW  0D
00D18:  BTFSS  F9E.4
00D1A:  BRA    0D18
00D1C:  MOVWF  FAD
....................       printf("Ingresa el segundo operando \r");   //Indica al usuario que ingrese el segundo operando 
00D1E:  MOVLW  62
00D20:  MOVWF  FF6
00D22:  MOVLW  01
00D24:  MOVWF  FF7
00D26:  CALL   0226
....................        
....................       while((!kbhit()) || ((Bufer[posicion-1]!=13) && (posicion-1<tamanoBufer)));                          //Toque de tecla         
00D2A:  BTFSS  F9E.5
00D2C:  BRA    0D2A
00D2E:  MOVLW  01
00D30:  SUBWF  28,W
00D32:  CLRF   03
00D34:  ADDLW  1C
00D36:  MOVWF  FE9
00D38:  MOVLW  00
00D3A:  ADDWFC 03,W
00D3C:  MOVWF  FEA
00D3E:  MOVF   FEF,W
00D40:  SUBLW  0D
00D42:  BZ    0D4C
00D44:  MOVLW  01
00D46:  SUBWF  28,W
00D48:  SUBLW  0A
00D4A:  BC    0D2A
....................       if(Bufer[posicion-1]==13)    Bufer[posicion-1]=0; 
00D4C:  MOVLW  01
00D4E:  SUBWF  28,W
00D50:  CLRF   03
00D52:  ADDLW  1C
00D54:  MOVWF  FE9
00D56:  MOVLW  00
00D58:  ADDWFC 03,W
00D5A:  MOVWF  FEA
00D5C:  MOVF   FEF,W
00D5E:  SUBLW  0D
00D60:  BNZ   0D74
00D62:  MOVLW  01
00D64:  SUBWF  28,W
00D66:  CLRF   03
00D68:  ADDLW  1C
00D6A:  MOVWF  FE9
00D6C:  MOVLW  00
00D6E:  ADDWFC 03,W
00D70:  MOVWF  FEA
00D72:  CLRF   FEF
....................       if(banderaError) 
00D74:  MOVF   27,F
00D76:  BZ    0D86
....................       { 
....................          printf("Dato incorrecto"); 
00D78:  MOVLW  80
00D7A:  MOVWF  FF6
00D7C:  MOVLW  01
00D7E:  MOVWF  FF7
00D80:  CALL   0226
....................          goto inicio; 
00D84:  BRA    0C26
....................       } 
....................       segundoOperando=atof(Bufer);                //Asigna la cifra casteandola a un flotante, a segundo operando en "segundoOperando" 
00D86:  CLRF   37
00D88:  MOVLW  1C
00D8A:  MOVWF  36
00D8C:  CLRF   39
00D8E:  CLRF   38
00D90:  RCALL  0734
00D92:  MOVFF  03,30
00D96:  MOVFF  02,2F
00D9A:  MOVFF  01,2E
00D9E:  MOVFF  00,2D
....................       posicion=0; 
00DA2:  CLRF   28
....................       printf("%4.4f\r",segundoOperando);              //Muestra el operando ingresado 
00DA4:  MOVLW  89
00DA6:  MOVWF  FE9
00DA8:  MOVFF  30,39
00DAC:  MOVFF  2F,38
00DB0:  MOVFF  2E,37
00DB4:  MOVFF  2D,36
00DB8:  MOVLW  04
00DBA:  MOVWF  3A
00DBC:  RCALL  0A34
00DBE:  MOVLW  0D
00DC0:  BTFSS  F9E.4
00DC2:  BRA    0DC0
00DC4:  MOVWF  FAD
....................       limpiarBufer(); 
00DC6:  CALL   0206
....................       //enable_interrupts(int_rda); 
....................       //printf("%4.4f\r",segundoOperando);             //Muestra el operando ingresado 
....................       //Pide Operacion 
....................       printf("Seleccione una operacion: \r 1)Suma  2)Resta  3)Multiplicacion  4)Division \r");    //Indica al usuario que selecione segun su nmero, una operacin  
00DCA:  MOVLW  90
00DCC:  MOVWF  FF6
00DCE:  MOVLW  01
00DD0:  MOVWF  FF7
00DD2:  CALL   0226
....................       while(!kbhit());                          //Toque de tecla 
00DD6:  BTFSS  F9E.5
00DD8:  BRA    0DD6
....................       operacion=Bufer[0];                      //Asigna la operacin casteandola a un flotante, a operacion 
00DDA:  MOVFF  1C,35
....................    
....................       //Saca resultado con los dos operadores ingresados y deacuerdo a la operacin seleccionada 
....................       if(operacion=='1')   resultado=primerOperando+segundoOperando;          //suma 
00DDE:  MOVF   35,W
00DE0:  SUBLW  31
00DE2:  BNZ   0E1C
00DE4:  BCF    FD8.1
00DE6:  MOVFF  2C,4C
00DEA:  MOVFF  2B,4B
00DEE:  MOVFF  2A,4A
00DF2:  MOVFF  29,49
00DF6:  MOVFF  30,50
00DFA:  MOVFF  2F,4F
00DFE:  MOVFF  2E,4E
00E02:  MOVFF  2D,4D
00E06:  CALL   04CA
00E0A:  MOVFF  03,34
00E0E:  MOVFF  02,33
00E12:  MOVFF  01,32
00E16:  MOVFF  00,31
00E1A:  BRA    0ED0
....................       else if(operacion=='2')   resultado=primerOperando-segundoOperando;     //resta 
00E1C:  MOVF   35,W
00E1E:  SUBLW  32
00E20:  BNZ   0E5A
00E22:  BSF    FD8.1
00E24:  MOVFF  2C,4C
00E28:  MOVFF  2B,4B
00E2C:  MOVFF  2A,4A
00E30:  MOVFF  29,49
00E34:  MOVFF  30,50
00E38:  MOVFF  2F,4F
00E3C:  MOVFF  2E,4E
00E40:  MOVFF  2D,4D
00E44:  CALL   04CA
00E48:  MOVFF  03,34
00E4C:  MOVFF  02,33
00E50:  MOVFF  01,32
00E54:  MOVFF  00,31
00E58:  BRA    0ED0
....................       else if(operacion=='3')   resultado=primerOperando*segundoOperando;     //multiplicacion 
00E5A:  MOVF   35,W
00E5C:  SUBLW  33
00E5E:  BNZ   0E96
00E60:  MOVFF  2C,48
00E64:  MOVFF  2B,47
00E68:  MOVFF  2A,46
00E6C:  MOVFF  29,45
00E70:  MOVFF  30,4C
00E74:  MOVFF  2F,4B
00E78:  MOVFF  2E,4A
00E7C:  MOVFF  2D,49
00E80:  CALL   0248
00E84:  MOVFF  03,34
00E88:  MOVFF  02,33
00E8C:  MOVFF  01,32
00E90:  MOVFF  00,31
00E94:  BRA    0ED0
....................       else if(operacion=='4')   resultado=primerOperando/segundoOperando;     //divicion 
00E96:  MOVF   35,W
00E98:  SUBLW  34
00E9A:  BNZ   0ED0
00E9C:  MOVFF  2C,4C
00EA0:  MOVFF  2B,4B
00EA4:  MOVFF  2A,4A
00EA8:  MOVFF  29,49
00EAC:  MOVFF  30,50
00EB0:  MOVFF  2F,4F
00EB4:  MOVFF  2E,4E
00EB8:  MOVFF  2D,4D
00EBC:  CALL   0370
00EC0:  MOVFF  03,34
00EC4:  MOVFF  02,33
00EC8:  MOVFF  01,32
00ECC:  MOVFF  00,31
....................       //Muestra resultado 
....................       printf("El resultado de la operacion es: %4.4f\r\r",resultado); 
00ED0:  MOVLW  DC
00ED2:  MOVWF  FF6
00ED4:  MOVLW  01
00ED6:  MOVWF  FF7
00ED8:  MOVLW  21
00EDA:  MOVWF  36
00EDC:  BRA    0BB6
00EDE:  MOVLW  89
00EE0:  MOVWF  FE9
00EE2:  MOVFF  34,39
00EE6:  MOVFF  33,38
00EEA:  MOVFF  32,37
00EEE:  MOVFF  31,36
00EF2:  MOVLW  04
00EF4:  MOVWF  3A
00EF6:  RCALL  0A34
00EF8:  MOVLW  0D
00EFA:  BTFSS  F9E.4
00EFC:  BRA    0EFA
00EFE:  MOVWF  FAD
00F00:  MOVLW  0D
00F02:  BTFSS  F9E.4
00F04:  BRA    0F02
00F06:  MOVWF  FAD
00F08:  BRA    0C42
....................    }  
.................... } 
.................... void limpiarBufer() 
*
00206:  CLRF   36
*
00F0A:  SLEEP 
.................... { 
....................    int i=0; 
....................    for(i=0; i<tamanoBufer; i++) 
*
00208:  CLRF   36
0020A:  MOVF   36,W
0020C:  SUBLW  0A
0020E:  BNC   0224
....................    { 
....................       Bufer[i]=0; 
00210:  CLRF   03
00212:  MOVF   36,W
00214:  ADDLW  1C
00216:  MOVWF  FE9
00218:  MOVLW  00
0021A:  ADDWFC 03,W
0021C:  MOVWF  FEA
0021E:  CLRF   FEF
00220:  INCF   36,F
00222:  BRA    020A
....................    } 
00224:  RETURN 0
.................... } 

Configuration Fuses:
   Word  1: 0800   INTRC_IO NOFCMEN NOIESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 0500   CCP2C1 NOPBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
