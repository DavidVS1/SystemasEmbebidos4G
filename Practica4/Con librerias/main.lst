CCS PCH C Compiler, Version 5.012, 41559               03-may.-17 15:48

               Filename:   C:\Users\luis\Documents\4Semestre\Embebidos\SystemasEmbebidos4G\Practica4\Con librerias\main.lst

               ROM used:   4636 bytes (7%)
                           Largest free fragment is 60896
               RAM used:   48 (1%) at main() level
                           109 (3%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   0E5C
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   01EA
00054:  BTFSS  F9D.5
00056:  GOTO   0060
0005A:  BTFSC  F9E.5
0005C:  GOTO   01C6
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVF   04,W
00098:  MOVFF  06,FE0
0009C:  MOVFF  05,FD8
000A0:  RETFIE 0
.................... #include <18F4620.h> 
.................... ///////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
000A2:  DATA 45,72
000A4:  DATA 72,6F
000A6:  DATA 72,20
000A8:  DATA 0A,0A
000AA:  DATA 0D,0D
000AC:  DATA 00,00
000AE:  DATA 53,65
000B0:  DATA 20,68
000B2:  DATA 61,20
000B4:  DATA 74,65
000B6:  DATA 72,6D
000B8:  DATA 69,6E
000BA:  DATA 61,64
000BC:  DATA 6F,20
000BE:  DATA 65,6C
000C0:  DATA 20,74
000C2:  DATA 69,65
000C4:  DATA 6D,70
000C6:  DATA 6F,20
000C8:  DATA 0A,0A
000CA:  DATA 0D,0D
000CC:  DATA 00,00
000CE:  DATA 45,72
000D0:  DATA 72,6F
000D2:  DATA 72,20
000D4:  DATA 0A,0A
000D6:  DATA 0D,0D
000D8:  DATA 00,00
*
0020E:  DATA 50,72
00210:  DATA 61,63
00212:  DATA 74,69
00214:  DATA 63,61
00216:  DATA 20,4E
00218:  DATA 6F,2E
0021A:  DATA 20,34
0021C:  DATA 20,0A
0021E:  DATA 0D,00
00220:  DATA 43,61
00222:  DATA 6C,63
00224:  DATA 75,6C
00226:  DATA 61,64
00228:  DATA 6F,72
0022A:  DATA 61,20
0022C:  DATA 41,72
0022E:  DATA 69,74
00230:  DATA 6D,65
00232:  DATA 74,69
00234:  DATA 63,61
00236:  DATA 20,0A
00238:  DATA 0A,0D
0023A:  DATA 0D,00
0023C:  DATA 49,6E
0023E:  DATA 67,72
00240:  DATA 65,73
00242:  DATA 61,20
00244:  DATA 65,6C
00246:  DATA 20,70
00248:  DATA 72,69
0024A:  DATA 6D,65
0024C:  DATA 72,20
0024E:  DATA 6F,70
00250:  DATA 65,72
00252:  DATA 61,6E
00254:  DATA 64,6F
00256:  DATA 20,0A
00258:  DATA 0D,00
0025A:  DATA 49,6E
0025C:  DATA 67,72
0025E:  DATA 65,73
00260:  DATA 61,20
00262:  DATA 65,6C
00264:  DATA 20,73
00266:  DATA 65,67
00268:  DATA 75,6E
0026A:  DATA 64,6F
0026C:  DATA 20,6F
0026E:  DATA 70,65
00270:  DATA 72,61
00272:  DATA 6E,64
00274:  DATA 6F,20
00276:  DATA 0A,0D
00278:  DATA 00,00
0027A:  DATA 53,65
0027C:  DATA 6C,65
0027E:  DATA 63,63
00280:  DATA 69,6F
00282:  DATA 6E,65
00284:  DATA 20,75
00286:  DATA 6E,61
00288:  DATA 20,6F
0028A:  DATA 70,65
0028C:  DATA 72,61
0028E:  DATA 63,69
00290:  DATA 6F,6E
00292:  DATA 3A,20
00294:  DATA 0A,0D
00296:  DATA 20,31
00298:  DATA 29,53
0029A:  DATA 75,6D
0029C:  DATA 61,20
0029E:  DATA 20,32
002A0:  DATA 29,52
002A2:  DATA 65,73
002A4:  DATA 74,61
002A6:  DATA 20,20
002A8:  DATA 33,29
002AA:  DATA 4D,75
002AC:  DATA 6C,74
002AE:  DATA 69,70
002B0:  DATA 6C,69
002B2:  DATA 63,61
002B4:  DATA 63,69
002B6:  DATA 6F,6E
002B8:  DATA 20,20
002BA:  DATA 34,29
002BC:  DATA 44,69
002BE:  DATA 76,69
002C0:  DATA 73,69
002C2:  DATA 6F,6E
002C4:  DATA 20,0A
002C6:  DATA 0D,00
002C8:  DATA 45,72
002CA:  DATA 72,6F
002CC:  DATA 72,20
002CE:  DATA 0A,0A
002D0:  DATA 0D,0D
002D2:  DATA 00,00
002D4:  DATA 45,6C
002D6:  DATA 20,72
002D8:  DATA 65,73
002DA:  DATA 75,6C
002DC:  DATA 74,61
002DE:  DATA 64,6F
002E0:  DATA 20,64
002E2:  DATA 65,20
002E4:  DATA 6C,61
002E6:  DATA 20,6F
002E8:  DATA 70,65
002EA:  DATA 72,61
002EC:  DATA 63,69
002EE:  DATA 6F,6E
002F0:  DATA 20,65
002F2:  DATA 73,3A
002F4:  DATA 20,25
002F6:  DATA 66,0A
002F8:  DATA 0A,0D
002FA:  DATA 0D,00
*
0031C:  TBLRD*+
0031E:  MOVF   FF5,F
00320:  BZ    033C
00322:  MOVFF  FF6,44
00326:  MOVFF  FF7,45
0032A:  MOVF   FF5,W
0032C:  BTFSS  F9E.4
0032E:  BRA    032C
00330:  MOVWF  FAD
00332:  MOVFF  44,FF6
00336:  MOVFF  45,FF7
0033A:  BRA    031C
0033C:  RETURN 0
*
00352:  MOVF   57,W
00354:  BTFSC  FD8.2
00356:  BRA    043A
00358:  MOVWF  00
0035A:  MOVF   5B,W
0035C:  BTFSC  FD8.2
0035E:  BRA    043A
00360:  ADDWF  00,F
00362:  BNC   036C
00364:  MOVLW  81
00366:  ADDWF  00,F
00368:  BC    043A
0036A:  BRA    0374
0036C:  MOVLW  7F
0036E:  SUBWF  00,F
00370:  BNC   043A
00372:  BZ    043A
00374:  MOVFF  58,5F
00378:  MOVF   5C,W
0037A:  XORWF  5F,F
0037C:  BSF    58.7
0037E:  BSF    5C.7
00380:  MOVF   5A,W
00382:  MULWF  5E
00384:  MOVFF  FF4,61
00388:  MOVF   59,W
0038A:  MULWF  5D
0038C:  MOVFF  FF4,03
00390:  MOVFF  FF3,60
00394:  MULWF  5E
00396:  MOVF   FF3,W
00398:  ADDWF  61,F
0039A:  MOVF   FF4,W
0039C:  ADDWFC 60,F
0039E:  MOVLW  00
003A0:  ADDWFC 03,F
003A2:  MOVF   5A,W
003A4:  MULWF  5D
003A6:  MOVF   FF3,W
003A8:  ADDWF  61,F
003AA:  MOVF   FF4,W
003AC:  ADDWFC 60,F
003AE:  MOVLW  00
003B0:  CLRF   02
003B2:  ADDWFC 03,F
003B4:  ADDWFC 02,F
003B6:  MOVF   58,W
003B8:  MULWF  5E
003BA:  MOVF   FF3,W
003BC:  ADDWF  60,F
003BE:  MOVF   FF4,W
003C0:  ADDWFC 03,F
003C2:  MOVLW  00
003C4:  ADDWFC 02,F
003C6:  MOVF   58,W
003C8:  MULWF  5D
003CA:  MOVF   FF3,W
003CC:  ADDWF  03,F
003CE:  MOVF   FF4,W
003D0:  ADDWFC 02,F
003D2:  MOVLW  00
003D4:  CLRF   01
003D6:  ADDWFC 01,F
003D8:  MOVF   5A,W
003DA:  MULWF  5C
003DC:  MOVF   FF3,W
003DE:  ADDWF  60,F
003E0:  MOVF   FF4,W
003E2:  ADDWFC 03,F
003E4:  MOVLW  00
003E6:  ADDWFC 02,F
003E8:  ADDWFC 01,F
003EA:  MOVF   59,W
003EC:  MULWF  5C
003EE:  MOVF   FF3,W
003F0:  ADDWF  03,F
003F2:  MOVF   FF4,W
003F4:  ADDWFC 02,F
003F6:  MOVLW  00
003F8:  ADDWFC 01,F
003FA:  MOVF   58,W
003FC:  MULWF  5C
003FE:  MOVF   FF3,W
00400:  ADDWF  02,F
00402:  MOVF   FF4,W
00404:  ADDWFC 01,F
00406:  INCF   00,F
00408:  BTFSC  01.7
0040A:  BRA    0416
0040C:  RLCF   60,F
0040E:  RLCF   03,F
00410:  RLCF   02,F
00412:  RLCF   01,F
00414:  DECF   00,F
00416:  MOVLW  00
00418:  BTFSS  60.7
0041A:  BRA    0430
0041C:  INCF   03,F
0041E:  ADDWFC 02,F
00420:  ADDWFC 01,F
00422:  MOVF   01,W
00424:  BNZ   0430
00426:  MOVF   02,W
00428:  BNZ   0430
0042A:  MOVF   03,W
0042C:  BNZ   0430
0042E:  INCF   00,F
00430:  BTFSC  5F.7
00432:  BSF    01.7
00434:  BTFSS  5F.7
00436:  BCF    01.7
00438:  BRA    0442
0043A:  CLRF   00
0043C:  CLRF   01
0043E:  CLRF   02
00440:  CLRF   03
00442:  RETURN 0
00444:  MOVLW  8E
00446:  MOVWF  00
00448:  MOVFF  5C,01
0044C:  MOVFF  5B,02
00450:  CLRF   03
00452:  MOVF   01,F
00454:  BNZ   0468
00456:  MOVFF  02,01
0045A:  CLRF   02
0045C:  MOVLW  08
0045E:  SUBWF  00,F
00460:  MOVF   01,F
00462:  BNZ   0468
00464:  CLRF   00
00466:  BRA    0478
00468:  BCF    FD8.0
0046A:  BTFSC  01.7
0046C:  BRA    0476
0046E:  RLCF   02,F
00470:  RLCF   01,F
00472:  DECF   00,F
00474:  BRA    0468
00476:  BCF    01.7
00478:  RETURN 0
0047A:  MOVF   5B,W
0047C:  BTFSC  FD8.2
0047E:  BRA    05CA
00480:  MOVWF  67
00482:  MOVF   5F,W
00484:  BTFSC  FD8.2
00486:  BRA    05CA
00488:  SUBWF  67,F
0048A:  BNC   0496
0048C:  MOVLW  7F
0048E:  ADDWF  67,F
00490:  BTFSC  FD8.0
00492:  BRA    05CA
00494:  BRA    04A2
00496:  MOVLW  81
00498:  SUBWF  67,F
0049A:  BTFSS  FD8.0
0049C:  BRA    05CA
0049E:  BTFSC  FD8.2
004A0:  BRA    05CA
004A2:  MOVFF  67,00
004A6:  CLRF   01
004A8:  CLRF   02
004AA:  CLRF   03
004AC:  CLRF   66
004AE:  MOVFF  5C,65
004B2:  BSF    65.7
004B4:  MOVFF  5D,64
004B8:  MOVFF  5E,63
004BC:  MOVLW  19
004BE:  MOVWF  67
004C0:  MOVF   62,W
004C2:  SUBWF  63,F
004C4:  BC    04E0
004C6:  MOVLW  01
004C8:  SUBWF  64,F
004CA:  BC    04E0
004CC:  SUBWF  65,F
004CE:  BC    04E0
004D0:  SUBWF  66,F
004D2:  BC    04E0
004D4:  INCF   66,F
004D6:  INCF   65,F
004D8:  INCF   64,F
004DA:  MOVF   62,W
004DC:  ADDWF  63,F
004DE:  BRA    0530
004E0:  MOVF   61,W
004E2:  SUBWF  64,F
004E4:  BC    050A
004E6:  MOVLW  01
004E8:  SUBWF  65,F
004EA:  BC    050A
004EC:  SUBWF  66,F
004EE:  BC    050A
004F0:  INCF   66,F
004F2:  INCF   65,F
004F4:  MOVF   61,W
004F6:  ADDWF  64,F
004F8:  MOVF   62,W
004FA:  ADDWF  63,F
004FC:  BNC   0530
004FE:  INCF   64,F
00500:  BNZ   0530
00502:  INCF   65,F
00504:  BNZ   0530
00506:  INCF   66,F
00508:  BRA    0530
0050A:  MOVF   60,W
0050C:  IORLW  80
0050E:  SUBWF  65,F
00510:  BC    052E
00512:  MOVLW  01
00514:  SUBWF  66,F
00516:  BC    052E
00518:  INCF   66,F
0051A:  MOVF   60,W
0051C:  IORLW  80
0051E:  ADDWF  65,F
00520:  MOVF   61,W
00522:  ADDWF  64,F
00524:  BNC   04F8
00526:  INCF   65,F
00528:  BNZ   04F8
0052A:  INCF   66,F
0052C:  BRA    04F8
0052E:  BSF    03.0
00530:  DECFSZ 67,F
00532:  BRA    0536
00534:  BRA    054C
00536:  BCF    FD8.0
00538:  RLCF   63,F
0053A:  RLCF   64,F
0053C:  RLCF   65,F
0053E:  RLCF   66,F
00540:  BCF    FD8.0
00542:  RLCF   03,F
00544:  RLCF   02,F
00546:  RLCF   01,F
00548:  RLCF   68,F
0054A:  BRA    04C0
0054C:  BTFSS  68.0
0054E:  BRA    055C
00550:  BCF    FD8.0
00552:  RRCF   01,F
00554:  RRCF   02,F
00556:  RRCF   03,F
00558:  RRCF   68,F
0055A:  BRA    0560
0055C:  DECF   00,F
0055E:  BZ    05CA
00560:  BTFSC  68.7
00562:  BRA    05A0
00564:  BCF    FD8.0
00566:  RLCF   63,F
00568:  RLCF   64,F
0056A:  RLCF   65,F
0056C:  RLCF   66,F
0056E:  MOVF   62,W
00570:  SUBWF  63,F
00572:  BC    0582
00574:  MOVLW  01
00576:  SUBWF  64,F
00578:  BC    0582
0057A:  SUBWF  65,F
0057C:  BC    0582
0057E:  SUBWF  66,F
00580:  BNC   05B6
00582:  MOVF   61,W
00584:  SUBWF  64,F
00586:  BC    0592
00588:  MOVLW  01
0058A:  SUBWF  65,F
0058C:  BC    0592
0058E:  SUBWF  66,F
00590:  BNC   05B6
00592:  MOVF   60,W
00594:  IORLW  80
00596:  SUBWF  65,F
00598:  BC    05A0
0059A:  MOVLW  01
0059C:  SUBWF  66,F
0059E:  BNC   05B6
005A0:  INCF   03,F
005A2:  BNZ   05B6
005A4:  INCF   02,F
005A6:  BNZ   05B6
005A8:  INCF   01,F
005AA:  BNZ   05B6
005AC:  INCF   00,F
005AE:  BZ    05CA
005B0:  RRCF   01,F
005B2:  RRCF   02,F
005B4:  RRCF   03,F
005B6:  MOVFF  5C,67
005BA:  MOVF   60,W
005BC:  XORWF  67,F
005BE:  BTFSS  67.7
005C0:  BRA    05C6
005C2:  BSF    01.7
005C4:  BRA    05D2
005C6:  BCF    01.7
005C8:  BRA    05D2
005CA:  CLRF   00
005CC:  CLRF   01
005CE:  CLRF   02
005D0:  CLRF   03
005D2:  RETURN 0
005D4:  MOVLW  80
005D6:  BTFSC  FD8.1
005D8:  XORWF  60,F
005DA:  CLRF   65
005DC:  CLRF   66
005DE:  MOVFF  5C,64
005E2:  MOVF   60,W
005E4:  XORWF  64,F
005E6:  MOVF   5B,W
005E8:  BTFSC  FD8.2
005EA:  BRA    07A4
005EC:  MOVWF  63
005EE:  MOVWF  00
005F0:  MOVF   5F,W
005F2:  BTFSC  FD8.2
005F4:  BRA    07B6
005F6:  SUBWF  63,F
005F8:  BTFSC  FD8.2
005FA:  BRA    06FE
005FC:  BNC   0678
005FE:  MOVFF  60,69
00602:  BSF    69.7
00604:  MOVFF  61,68
00608:  MOVFF  62,67
0060C:  CLRF   66
0060E:  BCF    FD8.0
00610:  RRCF   69,F
00612:  RRCF   68,F
00614:  RRCF   67,F
00616:  RRCF   66,F
00618:  DECFSZ 63,F
0061A:  BRA    060C
0061C:  BTFSS  64.7
0061E:  BRA    0626
00620:  BSF    65.0
00622:  BRA    07DE
00624:  BCF    65.0
00626:  BCF    63.0
00628:  BSF    65.4
0062A:  CLRF   FEA
0062C:  MOVLW  5E
0062E:  MOVWF  FE9
00630:  BRA    0804
00632:  BCF    65.4
00634:  BTFSC  64.7
00636:  BRA    064C
00638:  BTFSS  63.0
0063A:  BRA    0662
0063C:  RRCF   69,F
0063E:  RRCF   68,F
00640:  RRCF   67,F
00642:  RRCF   66,F
00644:  INCF   00,F
00646:  BTFSC  FD8.2
00648:  BRA    07D4
0064A:  BRA    0662
0064C:  BTFSC  69.7
0064E:  BRA    0668
00650:  BCF    FD8.0
00652:  RLCF   66,F
00654:  RLCF   67,F
00656:  RLCF   68,F
00658:  RLCF   69,F
0065A:  DECF   00,F
0065C:  BTFSC  FD8.2
0065E:  BRA    07D4
00660:  BRA    064C
00662:  BSF    65.6
00664:  BRA    073C
00666:  BCF    65.6
00668:  MOVFF  5C,64
0066C:  BTFSS  5C.7
0066E:  BRA    0674
00670:  BSF    69.7
00672:  BRA    07C6
00674:  BCF    69.7
00676:  BRA    07C6
00678:  MOVFF  5F,63
0067C:  MOVFF  5F,00
00680:  MOVF   5B,W
00682:  SUBWF  63,F
00684:  MOVFF  5C,69
00688:  BSF    69.7
0068A:  MOVFF  5D,68
0068E:  MOVFF  5E,67
00692:  CLRF   66
00694:  BCF    FD8.0
00696:  RRCF   69,F
00698:  RRCF   68,F
0069A:  RRCF   67,F
0069C:  RRCF   66,F
0069E:  DECFSZ 63,F
006A0:  BRA    0692
006A2:  BTFSS  64.7
006A4:  BRA    06AC
006A6:  BSF    65.1
006A8:  BRA    07DE
006AA:  BCF    65.1
006AC:  BCF    63.0
006AE:  BSF    65.5
006B0:  CLRF   FEA
006B2:  MOVLW  62
006B4:  MOVWF  FE9
006B6:  BRA    0804
006B8:  BCF    65.5
006BA:  BTFSC  64.7
006BC:  BRA    06D2
006BE:  BTFSS  63.0
006C0:  BRA    06E8
006C2:  RRCF   69,F
006C4:  RRCF   68,F
006C6:  RRCF   67,F
006C8:  RRCF   66,F
006CA:  INCF   00,F
006CC:  BTFSC  FD8.2
006CE:  BRA    07D4
006D0:  BRA    06E8
006D2:  BTFSC  69.7
006D4:  BRA    06EE
006D6:  BCF    FD8.0
006D8:  RLCF   66,F
006DA:  RLCF   67,F
006DC:  RLCF   68,F
006DE:  RLCF   69,F
006E0:  DECF   00,F
006E2:  BTFSC  FD8.2
006E4:  BRA    07D4
006E6:  BRA    06D2
006E8:  BSF    65.7
006EA:  BRA    073C
006EC:  BCF    65.7
006EE:  MOVFF  60,64
006F2:  BTFSS  60.7
006F4:  BRA    06FA
006F6:  BSF    69.7
006F8:  BRA    07C6
006FA:  BCF    69.7
006FC:  BRA    07C6
006FE:  MOVFF  60,69
00702:  BSF    69.7
00704:  MOVFF  61,68
00708:  MOVFF  62,67
0070C:  BTFSS  64.7
0070E:  BRA    0718
00710:  BCF    69.7
00712:  BSF    65.2
00714:  BRA    07DE
00716:  BCF    65.2
00718:  CLRF   66
0071A:  BCF    63.0
0071C:  CLRF   FEA
0071E:  MOVLW  5E
00720:  MOVWF  FE9
00722:  BRA    0804
00724:  BTFSC  64.7
00726:  BRA    0760
00728:  MOVFF  5C,64
0072C:  BTFSS  63.0
0072E:  BRA    073C
00730:  RRCF   69,F
00732:  RRCF   68,F
00734:  RRCF   67,F
00736:  RRCF   66,F
00738:  INCF   00,F
0073A:  BZ    07D4
0073C:  BTFSS  66.7
0073E:  BRA    0756
00740:  INCF   67,F
00742:  BNZ   0756
00744:  INCF   68,F
00746:  BNZ   0756
00748:  INCF   69,F
0074A:  BNZ   0756
0074C:  RRCF   69,F
0074E:  RRCF   68,F
00750:  RRCF   67,F
00752:  INCF   00,F
00754:  BZ    07D4
00756:  BTFSC  65.6
00758:  BRA    0666
0075A:  BTFSC  65.7
0075C:  BRA    06EC
0075E:  BRA    0798
00760:  MOVLW  80
00762:  XORWF  69,F
00764:  BTFSS  69.7
00766:  BRA    0770
00768:  BRA    07DE
0076A:  MOVFF  60,64
0076E:  BRA    0784
00770:  MOVFF  5C,64
00774:  MOVF   69,F
00776:  BNZ   0784
00778:  MOVF   68,F
0077A:  BNZ   0784
0077C:  MOVF   67,F
0077E:  BNZ   0784
00780:  CLRF   00
00782:  BRA    07C6
00784:  BTFSC  69.7
00786:  BRA    0798
00788:  BCF    FD8.0
0078A:  RLCF   66,F
0078C:  RLCF   67,F
0078E:  RLCF   68,F
00790:  RLCF   69,F
00792:  DECFSZ 00,F
00794:  BRA    0784
00796:  BRA    07D4
00798:  BTFSS  64.7
0079A:  BRA    07A0
0079C:  BSF    69.7
0079E:  BRA    07C6
007A0:  BCF    69.7
007A2:  BRA    07C6
007A4:  MOVFF  5F,00
007A8:  MOVFF  60,69
007AC:  MOVFF  61,68
007B0:  MOVFF  62,67
007B4:  BRA    07C6
007B6:  MOVFF  5B,00
007BA:  MOVFF  5C,69
007BE:  MOVFF  5D,68
007C2:  MOVFF  5E,67
007C6:  MOVFF  69,01
007CA:  MOVFF  68,02
007CE:  MOVFF  67,03
007D2:  BRA    083C
007D4:  CLRF   00
007D6:  CLRF   01
007D8:  CLRF   02
007DA:  CLRF   03
007DC:  BRA    083C
007DE:  CLRF   66
007E0:  COMF   67,F
007E2:  COMF   68,F
007E4:  COMF   69,F
007E6:  COMF   66,F
007E8:  INCF   66,F
007EA:  BNZ   07F6
007EC:  INCF   67,F
007EE:  BNZ   07F6
007F0:  INCF   68,F
007F2:  BNZ   07F6
007F4:  INCF   69,F
007F6:  BTFSC  65.0
007F8:  BRA    0624
007FA:  BTFSC  65.1
007FC:  BRA    06AA
007FE:  BTFSC  65.2
00800:  BRA    0716
00802:  BRA    076A
00804:  MOVF   FEF,W
00806:  ADDWF  67,F
00808:  BNC   0814
0080A:  INCF   68,F
0080C:  BNZ   0814
0080E:  INCF   69,F
00810:  BTFSC  FD8.2
00812:  BSF    63.0
00814:  MOVF   FED,F
00816:  MOVF   FEF,W
00818:  ADDWF  68,F
0081A:  BNC   0822
0081C:  INCF   69,F
0081E:  BTFSC  FD8.2
00820:  BSF    63.0
00822:  MOVF   FED,F
00824:  MOVF   FEF,W
00826:  BTFSC  FEF.7
00828:  BRA    082C
0082A:  XORLW  80
0082C:  ADDWF  69,F
0082E:  BTFSC  FD8.0
00830:  BSF    63.0
00832:  BTFSC  65.4
00834:  BRA    0632
00836:  BTFSC  65.5
00838:  BRA    06B8
0083A:  BRA    0724
0083C:  RETURN 0
*
00AA0:  MOVFF  50,57
00AA4:  MOVF   54,W
00AA6:  XORWF  57,F
00AA8:  BTFSS  57.7
00AAA:  BRA    0AB6
00AAC:  BCF    FD8.2
00AAE:  BCF    FD8.0
00AB0:  BTFSC  50.7
00AB2:  BSF    FD8.0
00AB4:  BRA    0B14
00AB6:  MOVFF  50,57
00ABA:  MOVFF  53,58
00ABE:  MOVF   4F,W
00AC0:  SUBWF  58,F
00AC2:  BZ    0AD0
00AC4:  BTFSS  57.7
00AC6:  BRA    0B14
00AC8:  MOVF   FD8,W
00ACA:  XORLW  01
00ACC:  MOVWF  FD8
00ACE:  BRA    0B14
00AD0:  MOVFF  54,58
00AD4:  MOVF   50,W
00AD6:  SUBWF  58,F
00AD8:  BZ    0AE6
00ADA:  BTFSS  57.7
00ADC:  BRA    0B14
00ADE:  MOVF   FD8,W
00AE0:  XORLW  01
00AE2:  MOVWF  FD8
00AE4:  BRA    0B14
00AE6:  MOVFF  55,58
00AEA:  MOVF   51,W
00AEC:  SUBWF  58,F
00AEE:  BZ    0AFC
00AF0:  BTFSS  57.7
00AF2:  BRA    0B14
00AF4:  MOVF   FD8,W
00AF6:  XORLW  01
00AF8:  MOVWF  FD8
00AFA:  BRA    0B14
00AFC:  MOVFF  56,58
00B00:  MOVF   52,W
00B02:  SUBWF  58,F
00B04:  BZ    0B12
00B06:  BTFSS  57.7
00B08:  BRA    0B14
00B0A:  MOVF   FD8,W
00B0C:  XORLW  01
00B0E:  MOVWF  FD8
00B10:  BRA    0B14
00B12:  BCF    FD8.0
00B14:  RETURN 0
*
00BEC:  MOVF   4C,W
00BEE:  SUBLW  B6
00BF0:  MOVWF  4C
00BF2:  CLRF   03
00BF4:  MOVFF  4D,50
00BF8:  BSF    4D.7
00BFA:  BCF    FD8.0
00BFC:  RRCF   4D,F
00BFE:  RRCF   4E,F
00C00:  RRCF   4F,F
00C02:  RRCF   03,F
00C04:  RRCF   02,F
00C06:  RRCF   01,F
00C08:  RRCF   00,F
00C0A:  DECFSZ 4C,F
00C0C:  BRA    0BFA
00C0E:  BTFSS  50.7
00C10:  BRA    0C28
00C12:  COMF   00,F
00C14:  COMF   01,F
00C16:  COMF   02,F
00C18:  COMF   03,F
00C1A:  INCF   00,F
00C1C:  BTFSC  FD8.2
00C1E:  INCF   01,F
00C20:  BTFSC  FD8.2
00C22:  INCF   02,F
00C24:  BTFSC  FD8.2
00C26:  INCF   03,F
00C28:  GOTO   0D0A (RETURN)
00C2C:  BTFSC  FD8.1
00C2E:  BRA    0C36
00C30:  CLRF   FEA
00C32:  MOVLW  54
00C34:  MOVWF  FE9
00C36:  CLRF   00
00C38:  CLRF   01
00C3A:  CLRF   02
00C3C:  CLRF   03
00C3E:  CLRF   54
00C40:  CLRF   55
00C42:  CLRF   56
00C44:  CLRF   57
00C46:  MOVF   53,W
00C48:  IORWF  52,W
00C4A:  IORWF  51,W
00C4C:  IORWF  50,W
00C4E:  BZ    0CA8
00C50:  MOVLW  20
00C52:  MOVWF  58
00C54:  BCF    FD8.0
00C56:  RLCF   4C,F
00C58:  RLCF   4D,F
00C5A:  RLCF   4E,F
00C5C:  RLCF   4F,F
00C5E:  RLCF   54,F
00C60:  RLCF   55,F
00C62:  RLCF   56,F
00C64:  RLCF   57,F
00C66:  MOVF   53,W
00C68:  SUBWF  57,W
00C6A:  BNZ   0C7C
00C6C:  MOVF   52,W
00C6E:  SUBWF  56,W
00C70:  BNZ   0C7C
00C72:  MOVF   51,W
00C74:  SUBWF  55,W
00C76:  BNZ   0C7C
00C78:  MOVF   50,W
00C7A:  SUBWF  54,W
00C7C:  BNC   0C9C
00C7E:  MOVF   50,W
00C80:  SUBWF  54,F
00C82:  MOVF   51,W
00C84:  BTFSS  FD8.0
00C86:  INCFSZ 51,W
00C88:  SUBWF  55,F
00C8A:  MOVF   52,W
00C8C:  BTFSS  FD8.0
00C8E:  INCFSZ 52,W
00C90:  SUBWF  56,F
00C92:  MOVF   53,W
00C94:  BTFSS  FD8.0
00C96:  INCFSZ 53,W
00C98:  SUBWF  57,F
00C9A:  BSF    FD8.0
00C9C:  RLCF   00,F
00C9E:  RLCF   01,F
00CA0:  RLCF   02,F
00CA2:  RLCF   03,F
00CA4:  DECFSZ 58,F
00CA6:  BRA    0C54
00CA8:  MOVFF  54,FEF
00CAC:  MOVFF  55,FEC
00CB0:  MOVFF  56,FEC
00CB4:  MOVFF  57,FEC
00CB8:  RETURN 0
00CBA:  MOVF   FE9,W
00CBC:  MOVWF  44
00CBE:  MOVF   43,W
00CC0:  MOVWF  46
00CC2:  BZ    0CF8
00CC4:  MOVFF  42,5A
00CC8:  MOVFF  41,59
00CCC:  MOVFF  40,58
00CD0:  MOVFF  3F,57
00CD4:  CLRF   5E
00CD6:  CLRF   5D
00CD8:  MOVLW  20
00CDA:  MOVWF  5C
00CDC:  MOVLW  82
00CDE:  MOVWF  5B
00CE0:  CALL   0352
00CE4:  MOVFF  03,42
00CE8:  MOVFF  02,41
00CEC:  MOVFF  01,40
00CF0:  MOVFF  00,3F
00CF4:  DECFSZ 46,F
00CF6:  BRA    0CC4
00CF8:  MOVFF  42,4F
00CFC:  MOVFF  41,4E
00D00:  MOVFF  40,4D
00D04:  MOVFF  3F,4C
00D08:  BRA    0BEC
00D0A:  MOVFF  03,42
00D0E:  MOVFF  02,41
00D12:  MOVFF  01,40
00D16:  MOVFF  00,3F
00D1A:  BTFSS  42.7
00D1C:  BRA    0D38
00D1E:  DECF   44,F
00D20:  BSF    44.5
00D22:  COMF   3F,F
00D24:  COMF   40,F
00D26:  COMF   41,F
00D28:  COMF   42,F
00D2A:  INCF   3F,F
00D2C:  BTFSC  FD8.2
00D2E:  INCF   40,F
00D30:  BTFSC  FD8.2
00D32:  INCF   41,F
00D34:  BTFSC  FD8.2
00D36:  INCF   42,F
00D38:  MOVLW  3B
00D3A:  MOVWF  4B
00D3C:  MOVLW  9A
00D3E:  MOVWF  4A
00D40:  MOVLW  CA
00D42:  MOVWF  49
00D44:  CLRF   48
00D46:  MOVLW  0A
00D48:  MOVWF  46
00D4A:  MOVF   43,W
00D4C:  BTFSC  FD8.2
00D4E:  INCF   44,F
00D50:  BSF    FD8.1
00D52:  CLRF   FEA
00D54:  MOVLW  3F
00D56:  MOVWF  FE9
00D58:  MOVFF  42,4F
00D5C:  MOVFF  41,4E
00D60:  MOVFF  40,4D
00D64:  MOVFF  3F,4C
00D68:  MOVFF  4B,53
00D6C:  MOVFF  4A,52
00D70:  MOVFF  49,51
00D74:  MOVFF  48,50
00D78:  RCALL  0C2C
00D7A:  MOVF   01,W
00D7C:  MOVF   00,F
00D7E:  BNZ   0D9E
00D80:  INCF   43,W
00D82:  SUBWF  46,W
00D84:  BZ    0D9E
00D86:  MOVF   44,W
00D88:  BZ    0DA2
00D8A:  ANDLW  0F
00D8C:  SUBWF  46,W
00D8E:  BZ    0D92
00D90:  BC    0E08
00D92:  BTFSC  44.7
00D94:  BRA    0E08
00D96:  BTFSC  44.6
00D98:  BRA    0DA2
00D9A:  MOVLW  20
00D9C:  BRA    0DFE
00D9E:  MOVLW  20
00DA0:  ANDWF  44,F
00DA2:  BTFSS  44.5
00DA4:  BRA    0DC0
00DA6:  BCF    44.5
00DA8:  MOVF   43,W
00DAA:  BTFSS  FD8.2
00DAC:  DECF   44,F
00DAE:  MOVF   00,W
00DB0:  MOVWF  44
00DB2:  MOVLW  2D
00DB4:  BTFSS  F9E.4
00DB6:  BRA    0DB4
00DB8:  MOVWF  FAD
00DBA:  MOVF   44,W
00DBC:  MOVWF  00
00DBE:  CLRF   44
00DC0:  MOVF   43,W
00DC2:  SUBWF  46,W
00DC4:  BNZ   0DDC
00DC6:  MOVF   00,W
00DC8:  MOVWF  44
00DCA:  MOVLW  2E
00DCC:  BTFSS  F9E.4
00DCE:  BRA    0DCC
00DD0:  MOVWF  FAD
00DD2:  MOVF   44,W
00DD4:  MOVWF  00
00DD6:  MOVLW  20
00DD8:  ANDWF  44,F
00DDA:  MOVLW  00
00DDC:  MOVLW  30
00DDE:  BTFSS  44.5
00DE0:  BRA    0DFE
00DE2:  BCF    44.5
00DE4:  MOVF   43,W
00DE6:  BTFSS  FD8.2
00DE8:  DECF   44,F
00DEA:  MOVF   00,W
00DEC:  MOVWF  44
00DEE:  MOVLW  2D
00DF0:  BTFSS  F9E.4
00DF2:  BRA    0DF0
00DF4:  MOVWF  FAD
00DF6:  MOVF   44,W
00DF8:  MOVWF  00
00DFA:  CLRF   44
00DFC:  MOVLW  30
00DFE:  ADDWF  00,F
00E00:  MOVF   00,W
00E02:  BTFSS  F9E.4
00E04:  BRA    0E02
00E06:  MOVWF  FAD
00E08:  BCF    FD8.1
00E0A:  MOVFF  4B,4F
00E0E:  MOVFF  4A,4E
00E12:  MOVFF  49,4D
00E16:  MOVFF  48,4C
00E1A:  CLRF   53
00E1C:  CLRF   52
00E1E:  CLRF   51
00E20:  MOVLW  0A
00E22:  MOVWF  50
00E24:  RCALL  0C2C
00E26:  MOVFF  03,4B
00E2A:  MOVFF  02,4A
00E2E:  MOVFF  01,49
00E32:  MOVFF  00,48
00E36:  DECFSZ 46,F
00E38:  BRA    0D50
00E3A:  RETURN 0
00E3C:  TBLRD*+
00E3E:  MOVFF  FF6,40
00E42:  MOVFF  FF7,41
00E46:  MOVF   FF5,W
00E48:  BTFSS  F9E.4
00E4A:  BRA    0E48
00E4C:  MOVWF  FAD
00E4E:  MOVFF  40,FF6
00E52:  MOVFF  41,FF7
00E56:  DECFSZ 3F,F
00E58:  BRA    0E3C
00E5A:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses HS, NOFCMEN, NOIESO, PUT, NOBROWNOUT, NOWDT  
.................... #fuses NOPBADEN, NOMCLR, STVREN, NOLVP, NODEBUG 
.................... #use delay(clock=16000000) 
.................... #use RS232(BAUD=9600,BITS=8,PARITY=N,XMIT=PIN_C6,RCV=PIN_C7,STOP=1)   
.................... #use standard_io(c) 
.................... #include "Librerias\matematicas.h" 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
0083E:  CLRF   4F
00840:  CLRF   4E
00842:  CLRF   4D
00844:  MOVLW  7F
00846:  MOVWF  4C
00848:  CLRF   53
0084A:  CLRF   52
0084C:  CLRF   51
0084E:  CLRF   50
00850:  BSF    54.0
00852:  BCF    54.1
00854:  BCF    54.2
00856:  CLRF   56
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
00858:  MOVF   48,W
0085A:  IORWF  49,W
0085C:  BNZ   0868
....................       return 0; 
0085E:  CLRF   00
00860:  CLRF   01
00862:  CLRF   02
00864:  CLRF   03
00866:  BRA    0A6E
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
00868:  MOVF   56,W
0086A:  INCF   56,F
0086C:  CLRF   03
0086E:  ADDWF  48,W
00870:  MOVWF  FE9
00872:  MOVF   49,W
00874:  ADDWFC 03,W
00876:  MOVWF  FEA
00878:  MOVFF  FEF,55
0087C:  MOVF   55,F
0087E:  BTFSC  FD8.2
00880:  BRA    09F8
....................    { 
....................       if (skip && !isspace(c)) 
00882:  BTFSS  54.0
00884:  BRA    08A4
00886:  MOVF   55,W
00888:  SUBLW  20
0088A:  BZ    08A4
....................       { 
....................          skip = 0; 
0088C:  BCF    54.0
....................          if (c == '+') 
0088E:  MOVF   55,W
00890:  SUBLW  2B
00892:  BNZ   089A
....................          { 
....................             sign = 0; 
00894:  BCF    54.1
....................             continue; 
00896:  BRA    09E2
....................          }             
00898:  BRA    08A4
....................          else if (c == '-') 
0089A:  MOVF   55,W
0089C:  SUBLW  2D
0089E:  BNZ   08A4
....................          { 
....................             sign = 1; 
008A0:  BSF    54.1
....................             continue; 
008A2:  BRA    09E2
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
008A4:  BTFSC  54.0
008A6:  BRA    08B6
008A8:  MOVF   55,W
008AA:  SUBLW  2E
008AC:  BNZ   08B6
008AE:  BTFSC  54.2
008B0:  BRA    08B6
....................          point = 1; 
008B2:  BSF    54.2
008B4:  BRA    09E2
....................       else if (!skip && isdigit(c)) 
008B6:  BTFSC  54.0
008B8:  BRA    09DC
008BA:  MOVF   55,W
008BC:  SUBLW  2F
008BE:  BTFSC  FD8.0
008C0:  BRA    09DC
008C2:  MOVF   55,W
008C4:  SUBLW  39
008C6:  BTFSS  FD8.0
008C8:  BRA    09DC
....................       { 
....................          c -= '0'; 
008CA:  MOVLW  30
008CC:  SUBWF  55,F
....................          if (point) 
008CE:  BTFSS  54.2
008D0:  BRA    0970
....................          { 
....................             pow10 = pow10 * 10.0; 
008D2:  MOVFF  4F,5A
008D6:  MOVFF  4E,59
008DA:  MOVFF  4D,58
008DE:  MOVFF  4C,57
008E2:  CLRF   5E
008E4:  CLRF   5D
008E6:  MOVLW  20
008E8:  MOVWF  5C
008EA:  MOVLW  82
008EC:  MOVWF  5B
008EE:  RCALL  0352
008F0:  MOVFF  03,4F
008F4:  MOVFF  02,4E
008F8:  MOVFF  01,4D
008FC:  MOVFF  00,4C
....................             result += (float)c / pow10;    
00900:  CLRF   5C
00902:  MOVFF  55,5B
00906:  RCALL  0444
00908:  MOVFF  03,5A
0090C:  MOVFF  02,59
00910:  MOVFF  01,58
00914:  MOVFF  00,57
00918:  MOVFF  03,5E
0091C:  MOVFF  02,5D
00920:  MOVFF  01,5C
00924:  MOVFF  00,5B
00928:  MOVFF  4F,62
0092C:  MOVFF  4E,61
00930:  MOVFF  4D,60
00934:  MOVFF  4C,5F
00938:  RCALL  047A
0093A:  BCF    FD8.1
0093C:  MOVFF  53,5E
00940:  MOVFF  52,5D
00944:  MOVFF  51,5C
00948:  MOVFF  50,5B
0094C:  MOVFF  03,62
00950:  MOVFF  02,61
00954:  MOVFF  01,60
00958:  MOVFF  00,5F
0095C:  RCALL  05D4
0095E:  MOVFF  03,53
00962:  MOVFF  02,52
00966:  MOVFF  01,51
0096A:  MOVFF  00,50
....................          } 
0096E:  BRA    09DA
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
00970:  CLRF   5A
00972:  CLRF   59
00974:  MOVLW  20
00976:  MOVWF  58
00978:  MOVLW  82
0097A:  MOVWF  57
0097C:  MOVFF  53,5E
00980:  MOVFF  52,5D
00984:  MOVFF  51,5C
00988:  MOVFF  50,5B
0098C:  RCALL  0352
0098E:  MOVFF  03,5A
00992:  MOVFF  02,59
00996:  MOVFF  01,58
0099A:  MOVFF  00,57
0099E:  CLRF   5C
009A0:  MOVFF  55,5B
009A4:  RCALL  0444
009A6:  BCF    FD8.1
009A8:  MOVFF  5A,5E
009AC:  MOVFF  59,5D
009B0:  MOVFF  58,5C
009B4:  MOVFF  57,5B
009B8:  MOVFF  03,62
009BC:  MOVFF  02,61
009C0:  MOVFF  01,60
009C4:  MOVFF  00,5F
009C8:  RCALL  05D4
009CA:  MOVFF  03,53
009CE:  MOVFF  02,52
009D2:  MOVFF  01,51
009D6:  MOVFF  00,50
....................          } 
....................       } 
009DA:  BRA    09E2
....................       else if (!skip) 
009DC:  BTFSC  54.0
009DE:  BRA    09E2
....................          break; 
009E0:  BRA    09F8
009E2:  MOVF   56,W
009E4:  INCF   56,F
009E6:  CLRF   03
009E8:  ADDWF  48,W
009EA:  MOVWF  FE9
009EC:  MOVF   49,W
009EE:  ADDWFC 03,W
009F0:  MOVWF  FEA
009F2:  MOVFF  FEF,55
009F6:  BRA    087C
....................    } 
....................  
....................    if (sign) 
009F8:  BTFSS  54.1
009FA:  BRA    0A2A
....................       result = -1*result; 
009FC:  CLRF   5A
009FE:  CLRF   59
00A00:  MOVLW  80
00A02:  MOVWF  58
00A04:  MOVLW  7F
00A06:  MOVWF  57
00A08:  MOVFF  53,5E
00A0C:  MOVFF  52,5D
00A10:  MOVFF  51,5C
00A14:  MOVFF  50,5B
00A18:  RCALL  0352
00A1A:  MOVFF  03,53
00A1E:  MOVFF  02,52
00A22:  MOVFF  01,51
00A26:  MOVFF  00,50
....................        
....................    if(endptr) 
00A2A:  MOVF   4A,W
00A2C:  IORWF  4B,W
00A2E:  BZ    0A5E
....................    { 
....................       if (ptr) { 
00A30:  MOVF   56,F
00A32:  BZ    0A4C
....................          ptr--; 
00A34:  DECF   56,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
00A36:  MOVFF  4A,FE9
00A3A:  MOVFF  4B,FEA
00A3E:  MOVF   56,W
00A40:  ADDWF  48,W
00A42:  MOVWF  FEF
00A44:  MOVLW  00
00A46:  ADDWFC 49,W
00A48:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
00A4A:  BRA    0A5E
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
00A4C:  MOVFF  4A,FE9
00A50:  MOVFF  4B,FEA
00A54:  MOVFF  49,FEC
00A58:  MOVF   FED,F
00A5A:  MOVFF  48,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
00A5E:  MOVFF  50,00
00A62:  MOVFF  51,01
00A66:  MOVFF  52,02
00A6A:  MOVFF  53,03
00A6E:  GOTO   0A7E (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... void calculos(float operacion,float primerOperando,float segundoOperando,float &resultado); 
.................... void calculos(float operacion,float primerOperando,float segundoOperando,float &resultado) 
.................... { 
....................       if(operacion==1)        resultado=primerOperando+segundoOperando;     //suma 
*
0100E:  MOVFF  42,52
01012:  MOVFF  41,51
01016:  MOVFF  40,50
0101A:  MOVFF  3F,4F
0101E:  CLRF   56
01020:  CLRF   55
01022:  CLRF   54
01024:  MOVLW  7F
01026:  MOVWF  53
01028:  RCALL  0AA0
0102A:  BNZ   1064
0102C:  BCF    FD8.1
0102E:  MOVFF  46,5E
01032:  MOVFF  45,5D
01036:  MOVFF  44,5C
0103A:  MOVFF  43,5B
0103E:  MOVFF  4A,62
01042:  MOVFF  49,61
01046:  MOVFF  48,60
0104A:  MOVFF  47,5F
0104E:  CALL   05D4
01052:  MOVFF  03,3A
01056:  MOVFF  02,39
0105A:  MOVFF  01,38
0105E:  MOVFF  00,37
01062:  BRA    1162
....................       else if(operacion==2)   resultado=primerOperando-segundoOperando;     //resta 
01064:  MOVFF  42,52
01068:  MOVFF  41,51
0106C:  MOVFF  40,50
01070:  MOVFF  3F,4F
01074:  CLRF   56
01076:  CLRF   55
01078:  CLRF   54
0107A:  MOVLW  80
0107C:  MOVWF  53
0107E:  RCALL  0AA0
01080:  BNZ   10BA
01082:  BSF    FD8.1
01084:  MOVFF  46,5E
01088:  MOVFF  45,5D
0108C:  MOVFF  44,5C
01090:  MOVFF  43,5B
01094:  MOVFF  4A,62
01098:  MOVFF  49,61
0109C:  MOVFF  48,60
010A0:  MOVFF  47,5F
010A4:  CALL   05D4
010A8:  MOVFF  03,3A
010AC:  MOVFF  02,39
010B0:  MOVFF  01,38
010B4:  MOVFF  00,37
010B8:  BRA    1162
....................       else if(operacion==3)   resultado=primerOperando*segundoOperando;     //multiplicacion 
010BA:  MOVFF  42,52
010BE:  MOVFF  41,51
010C2:  MOVFF  40,50
010C6:  MOVFF  3F,4F
010CA:  CLRF   56
010CC:  CLRF   55
010CE:  MOVLW  40
010D0:  MOVWF  54
010D2:  MOVLW  80
010D4:  MOVWF  53
010D6:  RCALL  0AA0
010D8:  BNZ   1110
010DA:  MOVFF  46,5A
010DE:  MOVFF  45,59
010E2:  MOVFF  44,58
010E6:  MOVFF  43,57
010EA:  MOVFF  4A,5E
010EE:  MOVFF  49,5D
010F2:  MOVFF  48,5C
010F6:  MOVFF  47,5B
010FA:  CALL   0352
010FE:  MOVFF  03,3A
01102:  MOVFF  02,39
01106:  MOVFF  01,38
0110A:  MOVFF  00,37
0110E:  BRA    1162
....................       else if(operacion==4)   resultado=primerOperando/segundoOperando;     //divicion 
01110:  MOVFF  42,52
01114:  MOVFF  41,51
01118:  MOVFF  40,50
0111C:  MOVFF  3F,4F
01120:  CLRF   56
01122:  CLRF   55
01124:  CLRF   54
01126:  MOVLW  81
01128:  MOVWF  53
0112A:  RCALL  0AA0
0112C:  BNZ   1162
0112E:  MOVFF  46,5E
01132:  MOVFF  45,5D
01136:  MOVFF  44,5C
0113A:  MOVFF  43,5B
0113E:  MOVFF  4A,62
01142:  MOVFF  49,61
01146:  MOVFF  48,60
0114A:  MOVFF  47,5F
0114E:  CALL   047A
01152:  MOVFF  03,3A
01156:  MOVFF  02,39
0115A:  MOVFF  01,38
0115E:  MOVFF  00,37
.................... } 
....................  
.................... #include "Librerias\ingresoDatos.h" 
.................... char Bufer[11]; 
.................... int datoMalo=0; 
.................... int posicion=0; 
.................... int terminadoRDA=0; 
.................... int timeOut=0; 
.................... unsigned int16 contador15s=0; 
.................... int8 punto=0; 
.................... int tamanoBufer=11; 
....................  
.................... void limpiarBufer(); 
.................... void datosnoCorrectos(); 
.................... int buscandoErrores(); 
.................... float valorIngresado(); 
.................... void ingresarDatos(); 
.................... void ingresarDatos() 
.................... {    
....................       posicion=0; 
*
0033E:  CLRF   28
....................       datoMalo=0; 
00340:  CLRF   27
....................       terminadoRDA=0; 
00342:  CLRF   29
....................       timeOut=0; 
00344:  CLRF   2A
....................       punto=0; 
00346:  CLRF   2D
....................       While(terminadoRDA==0);                   //Mientras no aya terminado de recivir la trama se queda ciclado 
00348:  MOVF   29,F
0034A:  BZ    0348
....................       contador15s=0;                            //Reinicia el contador15s 
0034C:  CLRF   2C
0034E:  CLRF   2B
00350:  RETURN 0
....................  
.................... } 
.................... int buscandoErrores() 
*
00B16:  CLRF   3F
.................... { 
....................    int error=0; 
....................    if(Bufer[posicion-1]==0x0A || Bufer[posicion-1]==0x0D)     //Si la ultima tecla presionada fue enter, la hace igual a NULL 
00B18:  MOVLW  01
00B1A:  SUBWF  28,W
00B1C:  CLRF   03
00B1E:  ADDLW  1C
00B20:  MOVWF  FE9
00B22:  MOVLW  00
00B24:  ADDWFC 03,W
00B26:  MOVWF  FEA
00B28:  MOVF   FEF,W
00B2A:  SUBLW  0A
00B2C:  BZ    0B44
00B2E:  MOVLW  01
00B30:  SUBWF  28,W
00B32:  CLRF   03
00B34:  ADDLW  1C
00B36:  MOVWF  FE9
00B38:  MOVLW  00
00B3A:  ADDWFC 03,W
00B3C:  MOVWF  FEA
00B3E:  MOVF   FEF,W
00B40:  SUBLW  0D
00B42:  BNZ   0B56
....................    { 
....................       Bufer[posicion-1]=0; 
00B44:  MOVLW  01
00B46:  SUBWF  28,W
00B48:  CLRF   03
00B4A:  ADDLW  1C
00B4C:  MOVWF  FE9
00B4E:  MOVLW  00
00B50:  ADDWFC 03,W
00B52:  MOVWF  FEA
00B54:  CLRF   FEF
....................    } 
....................    if(datoMalo==1 || Bufer[0]==0)                            //Si el dato ingresado no es correcto 
00B56:  DECFSZ 27,W
00B58:  BRA    0B5C
00B5A:  BRA    0B60
00B5C:  MOVF   1C,F
00B5E:  BNZ   0B80
....................    { 
....................        printf("Error \n\n\r\r"); 
00B60:  MOVLW  A2
00B62:  MOVWF  FF6
00B64:  MOVLW  00
00B66:  MOVWF  FF7
00B68:  CALL   031C
....................        if(timeOut==1) 
00B6C:  DECFSZ 2A,W
00B6E:  BRA    0B7C
....................        { 
....................          printf("Se ha terminado el tiempo \n\n\r\r"); 
00B70:  MOVLW  AE
00B72:  MOVWF  FF6
00B74:  MOVLW  00
00B76:  MOVWF  FF7
00B78:  CALL   031C
....................        } 
....................       error=1; 
00B7C:  MOVLW  01
00B7E:  MOVWF  3F
....................    } 
....................    float Operando=valorIngresado();                                //Asigna la cifra casteandola a un flotante, a primer operando en "primerOperando 
00B80:  RCALL  0A72
00B82:  MOVFF  03,43
00B86:  MOVFF  02,42
00B8A:  MOVFF  01,41
00B8E:  MOVFF  00,40
....................    if(Operando>9999.9999 || Operando<-9999.9999)          //Si el operando sale del valor permitido, lo manda a donde imprime Error 
00B92:  CLRF   52
00B94:  MOVLW  40
00B96:  MOVWF  51
00B98:  MOVLW  1C
00B9A:  MOVWF  50
00B9C:  MOVLW  8C
00B9E:  MOVWF  4F
00BA0:  MOVFF  43,56
00BA4:  MOVFF  42,55
00BA8:  MOVFF  41,54
00BAC:  MOVFF  40,53
00BB0:  RCALL  0AA0
00BB2:  BC    0BD6
00BB4:  MOVFF  43,52
00BB8:  MOVFF  42,51
00BBC:  MOVFF  41,50
00BC0:  MOVFF  40,4F
00BC4:  CLRF   56
00BC6:  MOVLW  40
00BC8:  MOVWF  55
00BCA:  MOVLW  9C
00BCC:  MOVWF  54
00BCE:  MOVLW  8C
00BD0:  MOVWF  53
00BD2:  RCALL  0AA0
00BD4:  BNC   0BE6
....................    { 
....................       printf("Error \n\n\r\r"); 
00BD6:  MOVLW  CE
00BD8:  MOVWF  FF6
00BDA:  MOVLW  00
00BDC:  MOVWF  FF7
00BDE:  CALL   031C
....................       error=1; 
00BE2:  MOVLW  01
00BE4:  MOVWF  3F
....................    } 
....................    return error; 
00BE6:  MOVFF  3F,01
00BEA:  RETURN 0
.................... } 
.................... float valorIngresado() 
*
00A72:  CLRF   49
00A74:  MOVLW  1C
00A76:  MOVWF  48
00A78:  CLRF   4B
00A7A:  CLRF   4A
00A7C:  BRA    083E
00A7E:  MOVFF  03,47
00A82:  MOVFF  02,46
00A86:  MOVFF  01,45
00A8A:  MOVFF  00,44
.................... { 
....................    float Operando=atof(Bufer); 
....................    return Operando; 
00A8E:  MOVFF  44,00
00A92:  MOVFF  45,01
00A96:  MOVFF  46,02
00A9A:  MOVFF  47,03
00A9E:  RETURN 0
.................... } 
.................... void limpiarBufer() 
*
002FC:  CLRF   3F
.................... { 
....................    int pos=0;                          //Variable para cambiar la posicion del vector Bufer 
....................    for(pos=0; pos<tamanoBufer; pos++) 
002FE:  CLRF   3F
00300:  MOVF   2E,W
00302:  SUBWF  3F,W
00304:  BC    031A
....................    { 
....................       Bufer[pos]=0; 
00306:  CLRF   03
00308:  MOVF   3F,W
0030A:  ADDLW  1C
0030C:  MOVWF  FE9
0030E:  MOVLW  00
00310:  ADDWFC 03,W
00312:  MOVWF  FEA
00314:  CLRF   FEF
00316:  INCF   3F,F
00318:  BRA    0300
....................    } 
0031A:  RETURN 0
.................... } 
.................... void datosnoCorrectos() 
.................... { 
....................    if(Bufer[posicion]==0x0A || Bufer[posicion]==0x0D)     //Si recivio enter 
*
000DA:  CLRF   03
000DC:  MOVF   28,W
000DE:  ADDLW  1C
000E0:  MOVWF  FE9
000E2:  MOVLW  00
000E4:  ADDWFC 03,W
000E6:  MOVWF  FEA
000E8:  MOVF   FEF,W
000EA:  SUBLW  0A
000EC:  BZ    0102
000EE:  CLRF   03
000F0:  MOVF   28,W
000F2:  ADDLW  1C
000F4:  MOVWF  FE9
000F6:  MOVLW  00
000F8:  ADDWFC 03,W
000FA:  MOVWF  FEA
000FC:  MOVF   FEF,W
000FE:  SUBLW  0D
00100:  BNZ   0106
....................    { 
....................       terminadoRDA=1; 
00102:  MOVLW  01
00104:  MOVWF  29
....................    } 
....................    if(!(posicion<tamanoBufer-1))                         //Si no es menor de 9 (la ultima posicin del vector para escribir), activa bandera para que termine la interrupcin 
00106:  MOVLW  01
00108:  SUBWF  2E,W
0010A:  SUBWF  28,W
0010C:  BNC   0112
....................    { 
....................       terminadoRDA=1; 
0010E:  MOVLW  01
00110:  MOVWF  29
....................    } 
....................    if(((Bufer[posicion]<'0' || Bufer[posicion]>'9') && (Bufer[posicion]!='-') && (Bufer[posicion]!='.') && (Bufer[posicion]!=0x0A && Bufer[posicion]!=0x0D)) || (posicion>0 && Bufer[posicion]=='-') || (punto>1))     //Si no ingreso un numero, un - o un .   El dato no es valido 
00112:  CLRF   03
00114:  MOVF   28,W
00116:  ADDLW  1C
00118:  MOVWF  FE9
0011A:  MOVLW  00
0011C:  ADDWFC 03,W
0011E:  MOVWF  FEA
00120:  MOVF   FEF,W
00122:  SUBLW  2F
00124:  BC    013A
00126:  CLRF   03
00128:  MOVF   28,W
0012A:  ADDLW  1C
0012C:  MOVWF  FE9
0012E:  MOVLW  00
00130:  ADDWFC 03,W
00132:  MOVWF  FEA
00134:  MOVF   FEF,W
00136:  SUBLW  39
00138:  BC    018A
0013A:  CLRF   03
0013C:  MOVF   28,W
0013E:  ADDLW  1C
00140:  MOVWF  FE9
00142:  MOVLW  00
00144:  ADDWFC 03,W
00146:  MOVWF  FEA
00148:  MOVF   FEF,W
0014A:  SUBLW  2D
0014C:  BZ    018A
0014E:  CLRF   03
00150:  MOVF   28,W
00152:  ADDLW  1C
00154:  MOVWF  FE9
00156:  MOVLW  00
00158:  ADDWFC 03,W
0015A:  MOVWF  FEA
0015C:  MOVF   FEF,W
0015E:  SUBLW  2E
00160:  BZ    018A
00162:  CLRF   03
00164:  MOVF   28,W
00166:  ADDLW  1C
00168:  MOVWF  FE9
0016A:  MOVLW  00
0016C:  ADDWFC 03,W
0016E:  MOVWF  FEA
00170:  MOVF   FEF,W
00172:  SUBLW  0A
00174:  BZ    018A
00176:  CLRF   03
00178:  MOVF   28,W
0017A:  ADDLW  1C
0017C:  MOVWF  FE9
0017E:  MOVLW  00
00180:  ADDWFC 03,W
00182:  MOVWF  FEA
00184:  MOVF   FEF,W
00186:  SUBLW  0D
00188:  BNZ   01A8
0018A:  MOVF   28,F
0018C:  BZ    01A2
0018E:  CLRF   03
00190:  MOVF   28,W
00192:  ADDLW  1C
00194:  MOVWF  FE9
00196:  MOVLW  00
00198:  ADDWFC 03,W
0019A:  MOVWF  FEA
0019C:  MOVF   FEF,W
0019E:  SUBLW  2D
001A0:  BZ    01A8
001A2:  MOVF   2D,W
001A4:  SUBLW  01
001A6:  BC    01AC
....................    { 
....................       datoMalo=1; 
001A8:  MOVLW  01
001AA:  MOVWF  27
....................    } 
....................    if(Bufer[posicion]=='.') 
001AC:  CLRF   03
001AE:  MOVF   28,W
001B0:  ADDLW  1C
001B2:  MOVWF  FE9
001B4:  MOVLW  00
001B6:  ADDWFC 03,W
001B8:  MOVWF  FEA
001BA:  MOVF   FEF,W
001BC:  SUBLW  2E
001BE:  BNZ   01C2
....................    { 
....................        punto++; 
001C0:  INCF   2D,F
....................    } 
001C2:  GOTO   01E2 (RETURN)
.................... } 
....................  
.................... #int_rda 
.................... void rda_isr() 
.................... {      
....................       Bufer[posicion]=getc();                     //Guarda lo tecleado en el Bufer en la posicion actual 
001C6:  CLRF   03
001C8:  MOVF   28,W
001CA:  ADDLW  1C
001CC:  MOVWF  FE9
001CE:  MOVLW  00
001D0:  ADDWFC 03,W
001D2:  MOVWF  FEA
001D4:  BTFSS  F9E.5
001D6:  BRA    01D4
001D8:  MOVFF  FAE,FEF
....................       contador15s=0; 
001DC:  CLRF   2C
001DE:  CLRF   2B
....................       datosnoCorrectos(); 
001E0:  BRA    00DA
....................       posicion++; 
001E2:  INCF   28,F
....................        
.................... } 
001E4:  BCF    F9E.5
001E6:  GOTO   0060
.................... #int_timer0 
.................... void contador_TMR0() 
.................... { 
....................    if(contador15s>=916) 
001EA:  MOVF   2C,W
001EC:  SUBLW  02
001EE:  BC    0202
001F0:  XORLW  FF
001F2:  BNZ   01FA
001F4:  MOVF   2B,W
001F6:  SUBLW  93
001F8:  BC    0202
....................    { 
....................       terminadoRDA=1; 
001FA:  MOVLW  01
001FC:  MOVWF  29
....................       datoMalo=1; 
001FE:  MOVWF  27
....................       timeOut=1; 
00200:  MOVWF  2A
....................    } 
....................    contador15s++; 
00202:  INCF   2B,F
00204:  BTFSC  FD8.2
00206:  INCF   2C,F
00208:  BCF    FF2.2
0020A:  GOTO   0060
.................... } 
....................  
....................  
.................... //#define tamanoBufer 11 
....................  
.................... void main(void) 
*
00E5C:  CLRF   FF8
00E5E:  BCF    FD0.7
00E60:  BSF    07.7
00E62:  BSF    FB8.3
00E64:  MOVLW  A0
00E66:  MOVWF  FAF
00E68:  MOVLW  01
00E6A:  MOVWF  FB0
00E6C:  MOVLW  A6
00E6E:  MOVWF  FAC
00E70:  MOVLW  90
00E72:  MOVWF  FAB
00E74:  CLRF   27
00E76:  CLRF   28
00E78:  CLRF   29
00E7A:  CLRF   2A
00E7C:  CLRF   2C
00E7E:  CLRF   2B
00E80:  CLRF   2D
00E82:  MOVLW  0B
00E84:  MOVWF  2E
00E86:  MOVF   FC1,W
00E88:  ANDLW  C0
00E8A:  IORLW  0F
00E8C:  MOVWF  FC1
00E8E:  MOVLW  07
00E90:  MOVWF  FB4
00E92:  CLRF   16
00E94:  CLRF   17
.................... { 
....................    //Configuraciones del microcontrolador 
....................    setup_oscillator(OSC_16MHZ); 
00E96:  MOVLW  60
00E98:  MOVWF  FD3
00E9A:  MOVLW  40
00E9C:  MOVWF  F9B
00E9E:  MOVF   FD3,W
....................    enable_interrupts(global); 
00EA0:  MOVLW  C0
00EA2:  IORWF  FF2,F
....................    enable_interrupts(int_rda); 
00EA4:  BSF    F9D.5
....................    SETUP_ADC_PORTS(NO_ANALOGS); 
00EA6:  MOVF   FC1,W
00EA8:  ANDLW  C0
00EAA:  IORLW  0F
00EAC:  MOVWF  FC1
....................    set_timer0(256); 
00EAE:  MOVLW  01
00EB0:  MOVWF  FD7
00EB2:  CLRF   FD6
....................    setup_timer_0(RTCC_internal|RTCC_DIV_256|RTCC_8_BIT); 
00EB4:  MOVLW  C7
00EB6:  MOVWF  FD5
....................    //Variables 
....................     
.................... inicio:   //Punto de retorno 
....................    float32 primerOperando=0, segundoOperando=0, resultado=0, operacion=0; 
00EB8:  CLRF   32
00EBA:  CLRF   31
00EBC:  CLRF   30
00EBE:  CLRF   2F
00EC0:  CLRF   36
00EC2:  CLRF   35
00EC4:  CLRF   34
00EC6:  CLRF   33
00EC8:  CLRF   3A
00ECA:  CLRF   39
00ECC:  CLRF   38
00ECE:  CLRF   37
00ED0:  CLRF   3E
00ED2:  CLRF   3D
00ED4:  CLRF   3C
00ED6:  CLRF   3B
....................     
....................    //// 
....................    while(true) 
....................    {    
....................       //Limpiamos Bufer 
....................       limpiarBufer(); 
00ED8:  CALL   02FC
....................        
....................       printf("Practica No. 4 \n\r"); 
00EDC:  MOVLW  0E
00EDE:  MOVWF  FF6
00EE0:  MOVLW  02
00EE2:  MOVWF  FF7
00EE4:  CALL   031C
....................       printf("Calculadora Aritmetica \n\n\r\r"); 
00EE8:  MOVLW  20
00EEA:  MOVWF  FF6
00EEC:  MOVLW  02
00EEE:  MOVWF  FF7
00EF0:  CALL   031C
....................                                                   //primerOperando 
....................       printf("Ingresa el primer operando \n\r");    //Indica al usuario que ingrese el primer operando 
00EF4:  MOVLW  3C
00EF6:  MOVWF  FF6
00EF8:  MOVLW  02
00EFA:  MOVWF  FF7
00EFC:  CALL   031C
....................       enable_interrupts(int_TIMER0);                  //Habilita la interrupcion de TMR0 
00F00:  BSF    FF2.5
....................       ingresarDatos();        
00F02:  CALL   033E
....................       disable_interrupts(int_TIMER0);            //Desactiva la interrupcin de TMR0 
00F06:  BCF    FF2.5
....................       ///Validaciones 
....................       if(buscandoErrores()==1) 
00F08:  RCALL  0B16
00F0A:  DECFSZ 01,W
00F0C:  BRA    0F10
....................       { 
....................          goto inicio; 
00F0E:  BRA    0EB8
....................       } 
....................       primerOperando=valorIngresado();                                //Asigna la cifra casteandola a un flotante, a primer operando en "primerOperando 
00F10:  RCALL  0A72
00F12:  MOVFF  03,32
00F16:  MOVFF  02,31
00F1A:  MOVFF  01,30
00F1E:  MOVFF  00,2F
....................       printf("%4.4f\n\r",primerOperando);              //Muestra el operando ingresado 
00F22:  MOVLW  89
00F24:  MOVWF  FE9
00F26:  MOVFF  32,42
00F2A:  MOVFF  31,41
00F2E:  MOVFF  30,40
00F32:  MOVFF  2F,3F
00F36:  MOVLW  04
00F38:  MOVWF  43
00F3A:  RCALL  0CBA
00F3C:  MOVLW  0A
00F3E:  BTFSS  F9E.4
00F40:  BRA    0F3E
00F42:  MOVWF  FAD
00F44:  MOVLW  0D
00F46:  BTFSS  F9E.4
00F48:  BRA    0F46
00F4A:  MOVWF  FAD
....................       limpiarBufer(); 
00F4C:  CALL   02FC
....................                                                      //segundoOperando 
....................       printf("Ingresa el segundo operando \n\r");    //Indica al usuario que ingrese el segundo operando 
00F50:  MOVLW  5A
00F52:  MOVWF  FF6
00F54:  MOVLW  02
00F56:  MOVWF  FF7
00F58:  CALL   031C
....................       enable_interrupts(int_TIMER0);                  //Habilita la interrupcion de TMR0 
00F5C:  BSF    FF2.5
....................       ingresarDatos();        
00F5E:  CALL   033E
....................       disable_interrupts(int_TIMER0);            //Desactiva la interrupcin de TMR0 
00F62:  BCF    FF2.5
....................       ///Validaciones 
....................       if(buscandoErrores()==1) 
00F64:  RCALL  0B16
00F66:  DECFSZ 01,W
00F68:  BRA    0F6C
....................       { 
....................          goto inicio; 
00F6A:  BRA    0EB8
....................       } 
....................       segundoOperando=valorIngresado();                                //Asigna la cifra casteandola a un flotante, a primer operando en "primerOperando 
00F6C:  RCALL  0A72
00F6E:  MOVFF  03,36
00F72:  MOVFF  02,35
00F76:  MOVFF  01,34
00F7A:  MOVFF  00,33
....................       printf("%4.4f\n\r",segundoOperando);              //Muestra el operando ingresado 
00F7E:  MOVLW  89
00F80:  MOVWF  FE9
00F82:  MOVFF  36,42
00F86:  MOVFF  35,41
00F8A:  MOVFF  34,40
00F8E:  MOVFF  33,3F
00F92:  MOVLW  04
00F94:  MOVWF  43
00F96:  RCALL  0CBA
00F98:  MOVLW  0A
00F9A:  BTFSS  F9E.4
00F9C:  BRA    0F9A
00F9E:  MOVWF  FAD
00FA0:  MOVLW  0D
00FA2:  BTFSS  F9E.4
00FA4:  BRA    0FA2
00FA6:  MOVWF  FAD
....................       limpiarBufer(); 
00FA8:  CALL   02FC
....................        
....................                                                                  //Operacion 
....................       printf("Seleccione una operacion: \n\r 1)Suma  2)Resta  3)Multiplicacion  4)Division \n\r");    //Indica al usuario que selecione segun su nmero, una operacin 
00FAC:  MOVLW  7A
00FAE:  MOVWF  FF6
00FB0:  MOVLW  02
00FB2:  MOVWF  FF7
00FB4:  CALL   031C
....................       enable_interrupts(int_TIMER0);                  //Habilita la interrupcion de TMR0 
00FB8:  BSF    FF2.5
....................       ingresarDatos();        
00FBA:  CALL   033E
....................       disable_interrupts(int_TIMER0);            //Desactiva la interrupcin de TMR0 
00FBE:  BCF    FF2.5
....................       ///Validaciones 
....................       if(buscandoErrores()==1) 
00FC0:  RCALL  0B16
00FC2:  DECFSZ 01,W
00FC4:  BRA    0FC8
....................       { 
....................          goto inicio; 
00FC6:  BRA    0EB8
....................       } 
....................       operacion=valorIngresado();                                //Asigna la cifra casteandola a un flotante, a primer operando en "primerOperando 
00FC8:  RCALL  0A72
00FCA:  MOVFF  03,3E
00FCE:  MOVFF  02,3D
00FD2:  MOVFF  01,3C
00FD6:  MOVFF  00,3B
....................       limpiarBufer(); 
00FDA:  CALL   02FC
....................    
....................       //Saca resultado con los dos operadores ingresados y deacuerdo a la operacin seleccionada 
....................       calculos(operacion,primerOperando,segundoOperando,resultado); 
00FDE:  MOVFF  3E,42
00FE2:  MOVFF  3D,41
00FE6:  MOVFF  3C,40
00FEA:  MOVFF  3B,3F
00FEE:  MOVFF  32,46
00FF2:  MOVFF  31,45
00FF6:  MOVFF  30,44
00FFA:  MOVFF  2F,43
00FFE:  MOVFF  36,4A
01002:  MOVFF  35,49
01006:  MOVFF  34,48
0100A:  MOVFF  33,47
....................       //Muestra resultado 
....................       if((segundoOperando==0 && operacion==4) || !(operacion>0 && operacion<5))           //Si quiere dividir entre 0. O no haya seleccionado ninguna operacin, se va ha error 
*
01162:  MOVFF  36,52
01166:  MOVFF  35,51
0116A:  MOVFF  34,50
0116E:  MOVFF  33,4F
01172:  CLRF   56
01174:  CLRF   55
01176:  CLRF   54
01178:  CLRF   53
0117A:  RCALL  0AA0
0117C:  BNZ   119C
0117E:  MOVFF  3E,52
01182:  MOVFF  3D,51
01186:  MOVFF  3C,50
0118A:  MOVFF  3B,4F
0118E:  CLRF   56
01190:  CLRF   55
01192:  CLRF   54
01194:  MOVLW  81
01196:  MOVWF  53
01198:  RCALL  0AA0
0119A:  BZ    11D8
0119C:  CLRF   52
0119E:  CLRF   51
011A0:  CLRF   50
011A2:  CLRF   4F
011A4:  MOVFF  3E,56
011A8:  MOVFF  3D,55
011AC:  MOVFF  3C,54
011B0:  MOVFF  3B,53
011B4:  RCALL  0AA0
011B6:  BNC   11D8
011B8:  MOVFF  3E,52
011BC:  MOVFF  3D,51
011C0:  MOVFF  3C,50
011C4:  MOVFF  3B,4F
011C8:  CLRF   56
011CA:  CLRF   55
011CC:  MOVLW  20
011CE:  MOVWF  54
011D0:  MOVLW  81
011D2:  MOVWF  53
011D4:  RCALL  0AA0
011D6:  BC    11E6
....................       { 
....................          printf("Error \n\n\r\r"); 
011D8:  MOVLW  C8
011DA:  MOVWF  FF6
011DC:  MOVLW  02
011DE:  MOVWF  FF7
011E0:  CALL   031C
....................          goto inicio; 
011E4:  BRA    0EB8
....................       } 
....................       printf("El resultado de la operacion es: %f\n\n\r\r",resultado); 
011E6:  MOVLW  D4
011E8:  MOVWF  FF6
011EA:  MOVLW  02
011EC:  MOVWF  FF7
011EE:  MOVLW  21
011F0:  MOVWF  3F
011F2:  RCALL  0E3C
011F4:  MOVLW  89
011F6:  MOVWF  FE9
011F8:  MOVFF  3A,42
011FC:  MOVFF  39,41
01200:  MOVFF  38,40
01204:  MOVFF  37,3F
01208:  MOVLW  02
0120A:  MOVWF  43
0120C:  RCALL  0CBA
0120E:  MOVLW  F7
01210:  MOVWF  FF6
01212:  MOVLW  02
01214:  MOVWF  FF7
01216:  MOVLW  04
01218:  MOVWF  3F
0121A:  RCALL  0E3C
0121C:  BRA    0ED8
....................       //resultado=0; 
....................    }  
.................... } 
....................  
0121E:  SLEEP 
.................... //Cambiar posicion por indexBufer 

Configuration Fuses:
   Word  1: 0200   HS NOFCMEN NOIESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 0500   CCP2C1 NOPBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
