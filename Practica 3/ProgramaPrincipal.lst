CCS PCH C Compiler, Version 5.012, 41559               02-abr.-17 20:27

               Filename:   C:\Users\luis\Documents\4Semestre\Embebidos\SystemasEmbebidos4G\Practica 3\ProgramaPrincipal.lst

               ROM used:   350 bytes (1%)
                           Largest free fragment is 65182
               RAM used:   28 (1%) at main() level
                           31 (1%) worst case
               Stack used: 2 locations (1 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   00C6
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   0096
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... #include <18F4620.h> 
.................... ///////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
*
0009E:  MOVF   1D,W
000A0:  CLRF   01
000A2:  SUBWF  1C,W
000A4:  BC    00AC
000A6:  MOVFF  1C,00
000AA:  BRA    00C4
000AC:  CLRF   00
000AE:  MOVLW  08
000B0:  MOVWF  1E
000B2:  RLCF   1C,F
000B4:  RLCF   00,F
000B6:  MOVF   1D,W
000B8:  SUBWF  00,W
000BA:  BTFSC  FD8.0
000BC:  MOVWF  00
000BE:  RLCF   01,F
000C0:  DECFSZ 1E,F
000C2:  BRA    00B2
000C4:  RETURN 0
....................  
.................... #list 
....................  
.................... #USE delay(clock=16000000)        //Configurando el reloj a 32Mhz 
.................... #fuses INTRC_IO, NOFCMEN, NOIESO, PUT, NOBROWNOUT, NOWDT 
.................... #fuses NOPBADEN, NOMCLR, STVREN, NOLVP, NODEBUG 
.................... int contadorDesvordamiento=0; 
.................... #int_TIMER0 
.................... void TIMER0_funcion(void) 
.................... { 
....................    contadorDesvordamiento++; 
*
00096:  INCF   16,F
00098:  BCF    FF2.2
0009A:  GOTO   0054
.................... } 
....................     
....................    void main(void) 
*
000C6:  CLRF   FF8
000C8:  BCF    FD0.7
000CA:  BSF    07.7
000CC:  CLRF   16
000CE:  MOVF   FC1,W
000D0:  ANDLW  C0
000D2:  IORLW  0F
000D4:  MOVWF  FC1
000D6:  MOVLW  07
000D8:  MOVWF  FB4
000DA:  CLRF   17
000DC:  CLRF   18
000DE:  CLRF   19
000E0:  CLRF   1A
000E2:  CLRF   1B
....................    { 
....................       int contadorDesvordamiento=0;   //Variable para contabilizar en numero de veces que se ejecuta la interrupcion TIMER0 
....................       int8 conAnilloA=0x10000000;            //Variable con el valor del valor para el contador de anillo del puerto A 
....................       int8 conAnilloB=0x10000000;             //Variable con el valor del valor para el contador de anillo del puerto B 
....................       int8 conAnilloC=0x10000000;             //Variable con el valor del valor para el contador de anillo del puerto C 
....................       int8 conAnilloD=0x10000000;             //Variable con el valor del valor para el contador de anillo del puerto D 
....................       setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256);   //Configuracion de la fuente y divisor del TMR0 
000E4:  MOVLW  87
000E6:  MOVWF  FD5
....................       enable_interrupts(int_TIMER0);  //Abilitamos la interrupcion TIMER0 
000E8:  BSF    FF2.5
....................       enable_interrupts(GLOBAL);      //Abilitamos las interrupciones globales 
000EA:  MOVLW  C0
000EC:  IORWF  FF2,F
....................       while(1)                        //Ciclo infinito 
....................       { 
....................          if(contadorDesvordamiento%1)   //Cada que pase una interrupción en TMR0, se ejecuta contador de anillo del puerto A 
000EE:  ANDLW  00
000F0:  BZ    0102
....................          { 
....................             output_a(conAnilloA);      //Imprimimos contador 
000F2:  CLRF   F92
000F4:  MOVFF  18,F89
....................             conAnilloA>>=1;            //Desplazamos el bit 
000F8:  BCF    FD8.0
000FA:  RRCF   18,F
....................             if(conAnilloA==0)          //Si el valor de conAnilloA sobrepaso el LSM, devuelbe el valor al MSB 
000FC:  MOVF   18,F
000FE:  BNZ   0102
....................             { 
....................                conAnilloA=0x10000000;  
00100:  CLRF   18
....................             } 
....................          } 
....................          if(contadorDesvordamiento%5)   //Cada cinco interrupciónes de TMR0, se ejecuta contador de anillo del puerto B 
00102:  MOVFF  17,1C
00106:  MOVLW  05
00108:  MOVWF  1D
0010A:  RCALL  009E
0010C:  MOVF   00,W
0010E:  BZ    0120
....................          { 
....................             output_b(conAnilloB);      //Imprimimos contador 
00110:  CLRF   F93
00112:  MOVFF  19,F8A
....................             conAnilloB>>=1;            //Desplazamos el bit 
00116:  BCF    FD8.0
00118:  RRCF   19,F
....................             if(conAnilloB==0)          //Si el valor de conAnilloB sobrepaso el LSM, devuelbe el valor al MSB 
0011A:  MOVF   19,F
0011C:  BNZ   0120
....................             { 
....................                conAnilloB=0x10000000;  
0011E:  CLRF   19
....................             } 
....................          } 
....................          if(contadorDesvordamiento%10)   //Cada diez interrupciónes de TMR0, se ejecuta contador de anillo del puerto C 
00120:  MOVFF  17,1C
00124:  MOVLW  0A
00126:  MOVWF  1D
00128:  RCALL  009E
0012A:  MOVF   00,W
0012C:  BZ    013E
....................          { 
....................             output_c(conAnilloC);      //Imprimimos contador 
0012E:  CLRF   F94
00130:  MOVFF  1A,F8B
....................             conAnilloC>>=1;            //Desplazamos el bit 
00134:  BCF    FD8.0
00136:  RRCF   1A,F
....................             if(conAnilloC==0)          //Si el valor de conAnilloC sobrepaso el LSM, devuelbe el valor al MSB 
00138:  MOVF   1A,F
0013A:  BNZ   013E
....................             { 
....................                conAnilloC=0x10000000;  
0013C:  CLRF   1A
....................             } 
....................          } 
....................          if(contadorDesvordamiento%15)   //Cada quince interrupciónes de TMR0, se ejecuta contador de anillo del puerto D 
0013E:  MOVFF  17,1C
00142:  MOVLW  0F
00144:  MOVWF  1D
00146:  RCALL  009E
00148:  MOVF   00,W
0014A:  BZ    015E
....................          { 
....................             output_d(conAnilloD);      //Imprimimos contador 
0014C:  CLRF   F95
0014E:  MOVFF  1B,F8C
....................             conAnilloD>>=1;            //Desplazamos el bit 
00152:  BCF    FD8.0
00154:  RRCF   1B,F
....................             if(conAnilloD==0)          //Si el valor de conAnilloD sobrepaso el LSM, devuelbe el valor al MSB 
00156:  MOVF   1B,F
00158:  BNZ   015C
....................             { 
....................                conAnilloD=0x10000000;  
0015A:  CLRF   1B
....................             } 
....................             contadorDesvordamiento=0;  //Devolvemos el valor del contador de desvordamientos del TMR0 a 0 para que solo cuente de 0 a 15 
0015C:  CLRF   17
....................          } 
0015E:  BRA    00EE
....................           
....................       } 
....................    } 
00160:  SLEEP 

Configuration Fuses:
   Word  1: 0800   INTRC_IO NOFCMEN NOIESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 0500   CCP2C1 NOPBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
