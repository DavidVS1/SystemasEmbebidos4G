CCS PCH C Compiler, Version 5.012, 41559               04-abr.-17 20:26

               Filename:   C:\Users\luis\Documents\4Semestre\Embebidos\SystemasEmbebidos4G\Practica 3\ProgramaPrincipal.lst

               ROM used:   340 bytes (1%)
                           Largest free fragment is 65192
               RAM used:   26 (1%) at main() level
                           30 (1%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   00A4
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   0096
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... #include <18F4620.h> 
.................... ///////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
....................  
.................... #list 
....................  
.................... #USE delay(clock=16000000)        //Configurando el reloj a 32Mhz 
.................... #fuses XT, NOFCMEN, NOIESO, PUT, NOBROWNOUT, NOWDT 
.................... #fuses NOPBADEN, NOMCLR, STVREN, NOLVP, NODEBUG 
.................... #use fast_io(a) 
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
.................... int contador_100ms=0;         //Declaramos variable contador para tiempo de 100ms. Sabremos cuantas veces se ha ejecutado la interrupción 
.................... int contador_500ms=0;         //Declaramos variable contador para tiempo de 100ms. Sabremos cuantas veces se ha ejecutado la interrupción 
.................... int contador_1000ms=0;        //Declaramos variable contador para tiempo de 100ms. Sabremos cuantas veces se ha ejecutado la interrupción 
.................... int contador_1500ms=0;        //Declaramos variable contador para tiempo de 100ms. Sabremos cuantas veces se ha ejecutado la interrupción 
.................... #int_timer0                  //Declaramos interrupción de TIMER0 
.................... void TIMER0_funcion(void)    //Funcion de interupción de TIMER0. Cada que ocurra una interrupcion de TIMER0 ingcrementara en uno las variables de los contadores de tiempo 
.................... { 
....................    contador_100ms++;          
00096:  INCF   16,F
....................    contador_500ms++; 
00098:  INCF   17,F
....................    contador_1000ms++; 
0009A:  INCF   18,F
....................    contador_1500ms++; 
0009C:  INCF   19,F
0009E:  BCF    FF2.2
000A0:  GOTO   0054
.................... } 
....................     
....................    void main(void) 
000A4:  CLRF   FF8
000A6:  BCF    FD0.7
000A8:  BSF    07.7
000AA:  CLRF   16
000AC:  CLRF   17
000AE:  CLRF   18
000B0:  CLRF   19
000B2:  MOVF   FC1,W
000B4:  ANDLW  C0
000B6:  IORLW  0F
000B8:  MOVWF  FC1
000BA:  MOVLW  07
000BC:  MOVWF  FB4
....................    { 
....................       setup_oscillator(OSC_16MHZ); 
000BE:  MOVLW  60
000C0:  MOVWF  FD3
000C2:  MOVLW  40
000C4:  MOVWF  F9B
000C6:  MOVF   FD3,W
....................       SETUP_ADC_PORTS(NO_ANALOGS); 
000C8:  MOVF   FC1,W
000CA:  ANDLW  C0
000CC:  IORLW  0F
000CE:  MOVWF  FC1
....................       int8 conAnilloA=0x20;             //Variable con el valor del valor para el contador de anillo del puerto A. Lo ponemos en el MSB 
....................       int8 conAnilloB=0x80;             //Variable con el valor del valor para el contador de anillo del puerto B. Lo ponemos en el MSB 
....................       int8 conAnilloC=0x80;             //Variable con el valor del valor para el contador de anillo del puerto C. Lo ponemos en el MSB 
....................       int8 conAnilloD=0x80;             //Variable con el valor del valor para el contador de anillo del puerto D. Lo ponemos en el MSB} 
000D0:  MOVLW  20
000D2:  MOVWF  1A
000D4:  MOVLW  80
000D6:  MOVWF  1B
000D8:  MOVWF  1C
000DA:  MOVWF  1D
....................       set_timer0(0); 
000DC:  CLRF   FD7
000DE:  CLRF   FD6
....................       setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|T0_8_BIT);   //Configuracion de la fuente y divisor del TMR0 <<<<<<Acomodar 
000E0:  MOVLW  C7
000E2:  MOVWF  FD5
....................       enable_interrupts(int_TIMER0);  //Abilitamos la interrupcion TIMER0 
000E4:  BSF    FF2.5
....................       enable_interrupts(GLOBAL);      //Abilitamos las interrupciones globales    
000E6:  MOVLW  C0
000E8:  IORWF  FF2,F
....................       // 
....................       //Configuramos puertos A,B,C y D como puertos de salida 
....................       set_tris_a(0); 
000EA:  MOVLW  00
000EC:  MOVWF  F92
....................       set_tris_b(0); 
000EE:  MOVWF  F93
....................       set_tris_c(0); 
000F0:  MOVWF  F94
....................       set_tris_d(0); 
000F2:  MOVWF  F95
....................       while(True)                        //Ciclo infinito 
....................       { 
....................          if(contador_100ms>=6)   //Si nuestro contador_100ms es mayor o igual a 6 quiere decir que ya han pasado 100ms desde que se desplazo conAnilloA entonces, se ejecuta contador de anillo del puerto A 
000F4:  MOVF   16,W
000F6:  SUBLW  05
000F8:  BC    0108
....................          { 
....................             conAnilloA>>=1;            //Desplazamos el bit del contador de anilo del puerto A 
000FA:  BCF    FD8.0
000FC:  RRCF   1A,F
....................             contador_100ms=0;          //Regresemos el valor de contador_100ms a 0 
000FE:  CLRF   16
....................             if(conAnilloA==0)          //Si el valor de conAnilloA sobrepaso el LSM, devuelbe el valor al MSB 
00100:  MOVF   1A,F
00102:  BNZ   0108
....................             { 
....................                conAnilloA=0x20;  
00104:  MOVLW  20
00106:  MOVWF  1A
....................             } 
....................          } 
....................          if(contador_500ms>=30)   //Si nuestro contador_500ms es mayor o igual a 30 quiere decir que ya han pasado 500ms desde que se desplazo conAnilloB entonces, se ejecuta contador de anillo del puerto B 
00108:  MOVF   17,W
0010A:  SUBLW  1D
0010C:  BC    011C
....................          { 
....................             conAnilloB>>=1;            //Desplazamos el bit del contador de anillo del puerto B 
0010E:  BCF    FD8.0
00110:  RRCF   1B,F
....................             contador_500ms=0;          //Regresemos el valor de contador_500ms a 0 
00112:  CLRF   17
....................             if(conAnilloB==0)          //Si el valor de conAnilloB sobrepaso el LSM, devuelbe el valor al MSB 
00114:  MOVF   1B,F
00116:  BNZ   011C
....................             { 
....................                conAnilloB=0x80;  
00118:  MOVLW  80
0011A:  MOVWF  1B
....................             } 
....................          } 
....................          if(contador_1000ms>=61)   //Si nuestro contador_1000ms es mayor o igual a 61 quiere decir que ya han pasado 1000ms desde que se desplazo conAnilloC entonces, se ejecuta contador de anillo del puerto C 
0011C:  MOVF   18,W
0011E:  SUBLW  3C
00120:  BC    0130
....................          { 
....................             conAnilloC>>=1;            //Desplazamos el bit del contador de anilo del puerto C 
00122:  BCF    FD8.0
00124:  RRCF   1C,F
....................             contador_1000ms=0;         //Regresemos el valor de contador_1000ms a 0 
00126:  CLRF   18
....................             if(conAnilloC==0)          //Si el valor de conAnilloC sobrepaso el LSM, devuelbe el valor al MSB 
00128:  MOVF   1C,F
0012A:  BNZ   0130
....................             { 
....................                conAnilloC=0x80;  
0012C:  MOVLW  80
0012E:  MOVWF  1C
....................             } 
....................          } 
....................          if(contador_1500ms>=91)   //Si nuestro contador_1500ms es mayor o igual a 91 quiere decir que ya han pasado 1500ms desde que se desplazo conAnilloD entonces, se ejecuta contador de anillo del puerto D 
00130:  MOVF   19,W
00132:  SUBLW  5A
00134:  BC    0144
....................          { 
....................             conAnilloD>>=1;            //Desplazamos el bit del contador de anilo del puerto D 
00136:  BCF    FD8.0
00138:  RRCF   1D,F
....................             contador_1500ms=0;         //Regresemos el valor de contador_1500ms a 0 
0013A:  CLRF   19
....................             if(conAnilloD==0)          //Si el valor de conAnilloD sobrepaso el LSM, devuelbe el valor al MSB 
0013C:  MOVF   1D,F
0013E:  BNZ   0144
....................             { 
....................                conAnilloD=0x80;  
00140:  MOVLW  80
00142:  MOVWF  1D
....................             } 
....................          } 
....................          //Imprimimos contadores de anillos de los puertos A,B,C y D 
....................          output_a(conAnilloA); 
00144:  MOVFF  1A,F89
....................          output_b(conAnilloB); 
00148:  MOVFF  1B,F8A
....................          output_c(conAnilloC); 
0014C:  MOVFF  1C,F8B
....................          output_d(conAnilloD); 
00150:  MOVFF  1D,F8C
00154:  BRA    00F4
....................           
....................       } 
....................    } 
....................     
00156:  SLEEP 

Configuration Fuses:
   Word  1: 0100   XT NOFCMEN NOIESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 0500   CCP2C1 NOPBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
